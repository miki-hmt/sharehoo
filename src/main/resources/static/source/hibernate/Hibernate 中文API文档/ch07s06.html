<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>7.6.&#160;更复杂的关联映射</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="ch07.html" title="第&#160;7&#160;章&#160;关联关系映射">
<link rel="prev" href="ch07s05.html" title="7.5.&#160;使用连接表的双向关联（Bidirectional associations with join tables）">
<link rel="next" href="ch08.html" title="第&#160;8&#160;章&#160;组件（Component）映射">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="assoc-complex"></a>7.6.&#160;更复杂的关联映射</h2></div></div></div>
<p>
            更复杂的关联连接<span class="emphasis"><em>极为</em></span>罕见。 
            通过在映射文档中嵌入SQL片断，Hibernate也可以处理更为复杂的情况。比如，假若包含历史帐户数据的表定义了<code class="literal">accountNumber</code>, <code class="literal">effectiveEndDate</code> 和<code class="literal">effectiveStartDate</code>字段，按照下面映射：
        </p>
<pre class="programlisting">&lt;properties name="currentAccountKey"&gt;
    &lt;property name="accountNumber" type="string" not-null="true"/&gt;
    &lt;property name="currentAccount" type="boolean"&gt;
        &lt;formula&gt;case when effectiveEndDate is null then 1 else 0 end&lt;/formula&gt;
    &lt;/property&gt;
&lt;/properties&gt;
&lt;property name="effectiveEndDate" type="date"/&gt;
&lt;property name="effectiveStateDate" type="date" not-null="true"/&gt;</pre>
<p>
        那么我们可以对<span class="emphasis"><em>目前(current)</em></span>实例(其<code class="literal">effectiveEndDate</code>为null)使用这样的关联映射:
        </p>
<pre class="programlisting">&lt;many-to-one name="currentAccountInfo" 
        property-ref="currentAccountKey"
        class="AccountInfo"&gt;
    &lt;column name="accountNumber"/&gt;
    &lt;formula&gt;'1'&lt;/formula&gt;
&lt;/many-to-one&gt;</pre>
<p>
            更复杂的例子,假想<code class="literal">Employee</code>和<code class="literal">Organization</code>之间的关联是通过一个<code class="literal">Employment</code>中间表维护的,而中间表中填充了很多历史雇员数据。那“雇员的<span class="emphasis"><em>最新</em></span>雇主”这个关联（最新雇主就是<code class="literal">startDate</code>最后的那个）可以这样映射：
        </p>
<pre class="programlisting">&lt;join&gt;
    &lt;key column="employeeId"/&gt;
    &lt;subselect&gt;
        select employeeId, orgId 
        from Employments 
        group by orgId 
        having startDate = max(startDate)
    &lt;/subselect&gt;
    &lt;many-to-one name="mostRecentEmployer" 
            class="Organization" 
            column="orgId"/&gt;
&lt;/join&gt;</pre>
<p>
        使用这一功能时可以充满创意，但通常更加实用的是用HQL或条件查询来处理这些情形。
        </p>
</div></body>
</html>
