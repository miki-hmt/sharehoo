<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>1.4.&#160;第三部分 - EventManager web应用程序</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="ch01.html" title="第&#160;1&#160;章&#160; Hibernate入门">
<link rel="prev" href="ch01s03.html" title="1.3.&#160; 第二部分 － 关联映射">
<link rel="next" href="ch01s05.html" title="1.5.&#160; 总结">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="tutorial-webapp"></a>1.4.&#160;第三部分 - EventManager web应用程序</h2></div></div></div>
<p>
            Hibernate web应用程序使用<code class="literal">Session</code> 和<code class="literal">Transaction</code>的方式几乎和独立应用程序是一样的。但是，有一些常见的模式（pattern）非常有用。现在我们编写一个<code class="literal">EventManagerServlet</code>。这个servlet可以列出数据库中保存的所有的events，还提供一个HTML表单来增加新的events。
        </p>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="tutorial-webapp-servlet"></a>1.4.1.&#160;编写基本的servlet</h3></div></div></div>
<p>
                在你的源代码目录的<code class="literal">events</code>包中创建一个新的类：
            </p>
<pre class="programlisting">package events;

// Imports

public class EventManagerServlet extends HttpServlet {

    // Servlet code
}</pre>
<p>
                我们后面会用到<code class="literal">dateFormatter</code> 的工具， 它把<code class="literal">Date</code>对象转换为字符串。只要一个formatter作为servlet的成员就可以了。
            </p>
<p>
                这个servlet只处理 HTTP <code class="literal">GET</code> 请求，因此，我们要实现的是<code class="literal">doGet()</code>方法：
            </p>
<pre class="programlisting">protected void doGet(HttpServletRequest request,
                     HttpServletResponse response)
        throws ServletException, IOException {

    SimpleDateFormat dateFormatter = new SimpleDateFormat("dd.MM.yyyy");

    try {
        // Begin unit of work
        HibernateUtil.getSessionFactory()
                .getCurrentSession().beginTransaction();

        // Process request and render page...

        // End unit of work
        HibernateUtil.getSessionFactory()
                .getCurrentSession().getTransaction().commit();

    } catch (Exception ex) {
        HibernateUtil.getSessionFactory()
                .getCurrentSession().getTransaction().rollback();
        throw new ServletException(ex);
    }

}</pre>
<p>
我们称这里应用的模式为每次请求一个session<span class="emphasis"><em>(session-per-request)</em></span>。当有请求到达这个servlet的时候，通过对<code class="literal">SessionFactory</code>的第一次调用，打开一个新的Hibernate <code class="literal">Session</code>。然后启动一个数据库事务―所有的数据访问都是在事务中进行，不管是读还是写（我们在应用程序中不使用auto-commit模式）。
            </p>
<p>

                <span class="emphasis"><em>不要</em></span>为每次数据库操作都使用一个新的Hibernate <code class="literal">Session</code>。将Hibernate <code class="literal">Session</code>的范围设置为整个请求。要用<code class="literal">getCurrentSession()</code>，这样它自动会绑定到当前Java线程。
            </p>
<p>
                下一步，对请求的可能动作进行处理，渲染出反馈的HTML。我们很快就会涉及到那部分。
            </p>
<p>
                最后，当处理与渲染都结束的时候，这个工作单元就结束了。假若在处理或渲染的时候有任何错误发生，会抛出一个异常，回滚数据库事务。这样，<code class="literal">session-per-request</code>模式就完成了。为了避免在每个servlet中都编写事务边界界定的代码，可以考虑写一个servlet 过滤器（filter）来更好地解决。关于这一模式的更多信息，请参阅Hibernate网站和Wiki，这一模式叫做<span class="emphasis"><em>Open Session in View</em></span>―只要你考虑用JSP来渲染你的视图（view），而不是在servlet中，你就会很快用到它。
            </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="tutorial-webapp-processing"></a>1.4.2.&#160;处理与渲染</h3></div></div></div>
<p>
                我们来实现处理请求以及渲染页面的工作。
            </p>
<pre class="programlisting">// Write HTML header
PrintWriter out = response.getWriter();
out.println("&lt;html&gt;&lt;head&gt;&lt;title&gt;Event Manager&lt;/title&gt;&lt;/head&gt;&lt;body&gt;");

// Handle actions
if ( "store".equals(request.getParameter("action")) ) {

    String eventTitle = request.getParameter("eventTitle");
    String eventDate = request.getParameter("eventDate");

    if ( "".equals(eventTitle) || "".equals(eventDate) ) {
        out.println("&lt;b&gt;&lt;i&gt;Please enter event title and date.&lt;/i&gt;&lt;/b&gt;");
    } else {
        createAndStoreEvent(eventTitle, dateFormatter.parse(eventDate));
        out.println("&lt;b&gt;&lt;i&gt;Added event.&lt;/i&gt;&lt;/b&gt;");
    }
}

// Print page
printEventForm(out);
listEvents(out, dateFormatter);

// Write HTML footer
out.println("&lt;/body&gt;&lt;/html&gt;");
out.flush();
out.close();</pre>
<p>
                <code class="literal">listEvents()</code>方法使用绑定到当前线程的Hibernate <code class="literal">Session</code>来执行查询：
            </p>
<pre class="programlisting">private void listEvents(PrintWriter out, SimpleDateFormat dateFormatter) {

    List result = HibernateUtil.getSessionFactory()
                    .getCurrentSession().createCriteria(Event.class).list();
    if (result.size() &gt; 0) {
        out.println("&lt;h2&gt;Events in database:&lt;/h2&gt;");
        out.println("&lt;table border='1'&gt;");
        out.println("&lt;tr&gt;");
        out.println("&lt;th&gt;Event title&lt;/th&gt;");
        out.println("&lt;th&gt;Event date&lt;/th&gt;");
        out.println("&lt;/tr&gt;");
        for (Iterator it = result.iterator(); it.hasNext();) {
            Event event = (Event) it.next();
            out.println("&lt;tr&gt;");
            out.println("&lt;td&gt;" + event.getTitle() + "&lt;/td&gt;");
            out.println("&lt;td&gt;" + dateFormatter.format(event.getDate()) + "&lt;/td&gt;");
            out.println("&lt;/tr&gt;");
        }
        out.println("&lt;/table&gt;");
    }
}</pre>
<p>
                最后，<code class="literal">store</code>动作会被导向到<code class="literal">createAndStoreEvent()</code>方法，它也使用当前线程的<code class="literal">Session</code>:
            </p>
<pre class="programlisting">protected void createAndStoreEvent(String title, Date theDate) {
    Event theEvent = new Event();
    theEvent.setTitle(title);
    theEvent.setDate(theDate);

    HibernateUtil.getSessionFactory()
                    .getCurrentSession().save(theEvent);
}</pre>
<p>
	大功告成，这个servlet写完了。Hibernate会在单一的<code class="literal">Session</code> 和<code class="literal">Transaction</code>中处理到达的servlet请求。如同在前面的独立应用程序中那样，Hibernate可以自动的把这些对象绑定到当前运行的线程中。这给了你用任何你喜欢的方式来对代码分层及访问<code class="literal">SessionFactory</code>的自由。通常，你会用更加完备的设计，把数据访问代码转移到数据访问对象中(DAO模式）。请参见Hibernate Wiki，那里有更多的例子。
            </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="tutorial-webapp-deploy"></a>1.4.3.&#160;部署与测试</h3></div></div></div>
<p>
	要发布这个程序，你得把它打成web发布包：WAR文件。把下面的脚本加入到你的<code class="literal">build.xml</code>中：
            </p>
<pre class="programlisting">&lt;target name="war" depends="compile"&gt;
    &lt;war destfile="hibernate-tutorial.war" webxml="web.xml"&gt;
        &lt;lib dir="${librarydir}"&gt;
          &lt;exclude name="jsdk*.jar"/&gt;
        &lt;/lib&gt;

        &lt;classes dir="${targetdir}"/&gt;
    &lt;/war&gt;
&lt;/target&gt;</pre>
<p>
	这段代码在你的开发目录中创建一个<code class="literal">hibernate-tutorial.war</code>的文件。它把所有的类库和<code class="literal">web.xml</code>描述文件都打包进去，web.xml 文件应该位于你的开发根目录中：
            </p>
<pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.4"
    xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;
        &lt;servlet-class&gt;events.EventManagerServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/eventmanager&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre>
<p>
                请注意在你编译和部署web应用程之前，需要一个附加的类库：<code class="literal">jsdk.jar</code>。这是Java Servlet开发包，假若你还没有，可以从Sun网站上下载，把它copy到你的lib目录。但是，它仅仅是在编译时需要，不会被打入WAR包。
            </p>
<p>
                在你的开发目录中，调用<code class="literal">ant war</code>来构建、打包，然后把<code class="literal">hibernate-tutorial.war</code>文件拷贝到你的tomcat的<code class="literal">webapps</code>目录下。假若你还没安装Tomcat，就去下载一个，按照指南来安装。对此应用的发布，你不需要修改任何Tomcat的配置。
            </p>
<p>
		在部署完，启动Tomcat之后，通过<code class="literal">http://localhost:8080/hibernate-tutorial/eventmanager</code>进行访问你的应用，在第一次servlet 请求发生时，请在Tomcat log中确认你看到Hibernate被初始化了（<code class="literal">HibernateUtil</code>的静态初始化器被调用），假若有任何异常抛出，也可以看到详细的输出。
            </p>
</div>
</div></body>
</html>
