<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>6.2.&#160;集合映射（ Collection mappings ）</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="ch06.html" title="第&#160;6&#160;章&#160;集合类(Collections)映射">
<link rel="prev" href="ch06.html" title="第&#160;6&#160;章&#160;集合类(Collections)映射">
<link rel="next" href="ch06s03.html" title="6.3.&#160;高级集合映射（Advanced collection mappings）">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="collections-mapping"></a>6.2.&#160;集合映射（ Collection mappings ）</h2></div></div></div>
<p>
        用于映射集合类的Hibernate映射元素取决于接口的类型。比如， <code class="literal">&lt;set&gt;</code> 元素用来映射<code class="literal">Set</code>类型的属性。
        </p>
<pre class="programlisting">&lt;class name="Product"&gt;
    &lt;id name="serialNumber" column="productSerialNumber"/&gt;
    &lt;set name="parts"&gt;
        &lt;key column="productSerialNumber" not-null="true"/&gt;
        &lt;one-to-many class="Part"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre>
<p>
        除了<code class="literal">&lt;set&gt;</code>,还有<code class="literal">&lt;list&gt;</code>, <code class="literal">&lt;map&gt;</code>,            <code class="literal">&lt;bag&gt;</code>, <code class="literal">&lt;array&gt;</code> 和
            <code class="literal">&lt;primitive-array&gt;</code> 映射元素。<code class="literal">&lt;map&gt;</code>具有代表性：
        </p>
<div class="programlistingco">
<pre class="programlisting">&lt;map
    name="propertyName"
    table="table_name"
    schema="schema_name"
    lazy="true|extra|false"
    inverse="true|false"
    cascade="all|none|save-update|delete|all-delete-orphan|delete-orphan"
    sort="unsorted|natural|comparatorClass"
    order-by="column_name asc|desc"
    where="arbitrary sql where condition"
    fetch="join|select|subselect"
    batch-size="N"
    access="field|property|ClassName"
    optimistic-lock="true|false"
    mutable="true|false"
    node="element-name|."
    embed-xml="true|false"
&gt;

    &lt;key .... /&gt;
    &lt;map-key .... /&gt;
    &lt;element .... /&gt;
&lt;/map&gt;</pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td>
<td valign="top" align="left"><p>
                            <code class="literal">name</code> 集合属性的名称
                        </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/2.png" alt="2" border="0"></td>
<td valign="top" align="left"><p>
							<code class="literal">table</code> （可选――默认为属性的名称）这个集合表的名称(不能在一对多的关联关系中使用)
                        </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/3.png" alt="3" border="0"></td>
<td valign="top" align="left"><p>
                            <code class="literal">schema</code> (可选) 表的schema的名称, 他将覆盖在根元素中定义的schema
                        </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/4.png" alt="4" border="0"></td>
<td valign="top" align="left"><p>
                            <code class="literal">lazy</code> (可选--默认为true) 可以用来关闭延迟加载(false)，指定一直使用预先抓取,或者打开"extra-lazy" 抓取，此时大多数操作不会初始化集合类(适用于非常大的集合)
                        </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/5.png" alt="5" border="0"></td>
<td valign="top" align="left"><p>
                            <code class="literal">inverse</code> (可选――默认为<code class="literal">false</code>)
                            标记这个集合作为双向关联关系中的方向一端。

                        </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/6.png" alt="6" border="0"></td>
<td valign="top" align="left"><p>
                            <code class="literal">cascade</code> (可选――默认为<code class="literal">none</code>)
                            让操作级联到子实体
                        </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/7.png" alt="7" border="0"></td>
<td valign="top" align="left"><p>
                            <code class="literal">sort</code>(可选)指定集合的排序顺序, 其可以为自然的(<code class="literal">natural</code>)或者给定一个用来比较的类。

                        </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/8.png" alt="8" border="0"></td>
<td valign="top" align="left"><p>
                            <code class="literal">order-by</code> (可选, 仅用于jdk1.4) 指定表的字段(一个或几个)再加上asc或者desc(可选), 定义Map,Set和Bag的迭代顺序
                        </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/9.png" alt="9" border="0"></td>
<td valign="top" align="left"><p>
                            <code class="literal">where</code> (可选) 指定任意的SQL where条件, 该条件将在重新载入或者删除这个集合时使用(当集合中的数据仅仅是所有可用数据的一个子集时这个条件非常有用)
                        </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/10.png" alt="10" border="0"></td>
<td valign="top" align="left"><p>
                        <code class="literal">fetch</code> (可选, 默认为<code class="literal">select</code>) 用于在外连接抓取、通过后续select抓取和通过后续subselect抓取之间选择。
                    </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/11.png" alt="11" border="0"></td>
<td valign="top" align="left"><p>
                            <code class="literal">batch-size</code> (可选, 默认为<code class="literal">1</code>) 指定通过延迟加载取得集合实例的批处理块大小（"batch size"）。
                        </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/12.png" alt="12" border="0"></td>
<td valign="top" align="left"><p>
                            <code class="literal">access</code>(可选-默认为属性property):Hibernate取得集合属性值时使用的策略
                        </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/13.png" alt="13" border="0"></td>
<td valign="top" align="left"><p>
                        <code class="literal">乐观锁</code> (可选 - 默认为 <code class="literal">true</code>): 
                        对集合的状态的改变会是否导致其所属的实体的版本增长。 (对一对多关联来说，关闭这个属性常常是有理的)
                    </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/14.png" alt="14" border="0"></td>
<td valign="top" align="left"><p>
                        <code class="literal">mutable(可变）</code> (可选 - 默认为<code class="literal">true</code>): 
                        若值为<code class="literal">false</code>,表明集合中的元素不会改变（在某些情况下可以进行一些小的性能优化）。
                    </p></td>
</tr>
</table></div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="collections-foreignkeys"></a>6.2.1.&#160;集合外键(Collection foreign keys)</h3></div></div></div>
<p>
            集合实例在数据库中依靠持有集合的实体的外键加以辨别。此外键作为<span class="emphasis"><em>集合关键字段（collection key column）</em></span>（或多个字段）加以引用。集合关键字段通过<code class="literal">&lt;key&gt;</code> 元素映射。
            </p>
<p>
                在外键字段上可能具有非空约束。对于大多数集合来说，这是隐含的。对单向一对多关联来说，外键字段默认是可以为空的，因此你可能需要指明 <code class="literal">not-null="true"</code>。
            </p>
<pre class="programlisting">&lt;key column="productSerialNumber" not-null="true"/&gt;</pre>
<p>
                外键约束可以使用<code class="literal">ON DELETE CASCADE</code>。
            </p>
<pre class="programlisting">&lt;key column="productSerialNumber" on-delete="cascade"/&gt;</pre>
<p>
                对<code class="literal">&lt;key&gt;</code> 元素的完整定义，请参阅前面的章节。
            </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="collections-elements"></a>6.2.2.&#160;集合元素（Collection elements）</h3></div></div></div>
<p>
              集合几乎可以包含任何其他的Hibernate类型，包括所有的基本类型、自定义类型、组件，当然还有对其他实体的引用。存在一个重要的区别：位于集合中的对象可能是根据“值”语义来操作（其声明周期完全依赖于集合持有者），或者它可能是指向另一个实体的引用，具有其自己的生命周期。在后者的情况下，被作为集合持有的状态考虑的，只有两个对象之间的“连接”。
            </p>
<p>
                被包容的类型被称为<span class="emphasis"><em>集合元素类型（collection element type）</em></span>。集合元素通过<code class="literal">&lt;element&gt;</code>或<code class="literal">&lt;composite-element&gt;</code>映射，或在其是实体引用的时候，通过<code class="literal">&lt;one-to-many&gt;</code> 或<code class="literal">&lt;many-to-many&gt;</code>映射。前两种用于使用值语义映射元素，后两种用于映射实体关联。
            </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="collections-indexed"></a>6.2.3.&#160;索引集合类(Indexed collections)</h3></div></div></div>
<p>
             所有的集合映射，除了set和bag语义的以外，都需要指定一个集合表的<span class="emphasis"><em>索引字段(index column)</em></span>――用于对应到数组索引，或者<code class="literal">List</code>的索引，或者<code class="literal">Map</code>的关键字。通过<code class="literal">&lt;map-key&gt;</code>,<code class="literal">Map</code> 的索引可以是任何基础类型；若通过<code class="literal">&lt;map-key-many-to-many&gt;</code>，它也可以是一个实体引用；若通过<code class="literal">&lt;composite-map-key&gt;</code>，它还可以是一个组合类型。数组或列表的索引必须是<code class="literal">integer</code>类型，并且使用 <code class="literal">&lt;list-index&gt;</code>元素定义映射。被映射的字段包含有顺序排列的整数（默认从0开始）。
            </p>
<div class="programlistingco">
<pre class="programlisting">&lt;map-key 
        column="column_name"
        formula="any SQL expression"
        type="type_name"
        node="@attribute-name"
        length="N"/&gt;</pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td>
<td valign="top" align="left"><p>
                            <code class="literal">column</code>(可选):保存集合索引值的字段名。
                        </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/2.png" alt="2" border="0"></td>
<td valign="top" align="left"><p>
                        <code class="literal">formula</code> (可选): 用于计算map关键字的SQL公式
                    </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/3.png" alt="3" border="0"></td>
<td valign="top" align="left"><p>
                            <code class="literal">type</code> (必须):映射键(map key)的类型。
                        </p></td>
</tr>
</table></div>
</div>
<div class="programlistingco">
<pre class="programlisting">&lt;map-key-many-to-many
        column="column_name"
        formula="any SQL expression"
        class="ClassName"
/&gt;</pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td>
<td valign="top" align="left"><p>
							<code class="literal">column</code>(可选):集合索引值中外键字段的名称
                        </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/2.png" alt="2" border="0"></td>
<td valign="top" align="left"><p>
                        <code class="literal">formula</code> (可选): 用于计算map关键字的外键的SQL公式
                    </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/3.png" alt="3" border="0"></td>
<td valign="top" align="left"><p>
                            <code class="literal">class</code> (必需):映射的键(map key)使用的实体类。
                        </p></td>
</tr>
</table></div>
</div>
<p>
            假若你的表没有一个索引字段,当你仍然希望使用<code class="literal">List</code>作为属性类型,你应该把此属性映射为Hibernate <span class="emphasis"><em>&lt;bag&gt;</em></span>。从数据库中获取的时候，bag不维护其顺序，但也可选择性的进行排序。
            </p>
</div>
<p>
        从集合类可以产生很大一部分映射，覆盖了很多常见的关系模型。我们建议你试验schema生成工具，来体会一下不同的映射声明是如何被翻译为数据库表的。
        </p>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="collections-ofvalues"></a>6.2.4.&#160;值集合于多对多关联(Collections of values and many-to-many associations)</h3></div></div></div>
<p>
        任何值集合或者多对多关联需要专用的具有一个或多个外键字段的<span class="emphasis"><em>collection table</em></span>、一个或多个<span class="emphasis"><em>collection element column</em></span>，以及还可能有一个或多个索引字段。
        </p>
<p>
                对于一个值集合, 我们使用<code class="literal">&lt;element&gt;</code>标签。
            </p>
<div class="programlistingco">
<pre class="programlisting">&lt;element
        column="column_name"
        formula="any SQL expression"
        type="typename"
        length="L"
        precision="P"
        scale="S"
        not-null="true|false"
        unique="true|false"
        node="element-name"
/&gt;</pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td>
<td valign="top" align="left"><p>
                            <code class="literal">column</code>(可选):保存集合元素值的字段名。
                        </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/2.png" alt="2" border="0"></td>
<td valign="top" align="left"><p>
                        <code class="literal">formula</code> (可选): 用于计算元素的SQL公式                    
                       </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/3.png" alt="3" border="0"></td>
<td valign="top" align="left"><p>
                            <code class="literal">type</code> (必需):集合元素的类型
                        </p></td>
</tr>
</table></div>
</div>
<p>
            <span class="emphasis"><em>多对多关联(many-to-many association)</em></span> 使用
            <code class="literal">&lt;many-to-many&gt;</code>元素定义.
        </p>
<div class="programlistingco">
<pre class="programlisting">&lt;many-to-many
        column="column_name"
        formula="any SQL expression"
        class="ClassName"
        fetch="select|join"
        unique="true|false"
        not-found="ignore|exception"
        entity-name="EntityName"
        property-ref="propertyNameFromAssociatedClass"
        node="element-name"
        embed-xml="true|false"
    /&gt;</pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td>
<td valign="top" align="left"><p>
                            <code class="literal">column</code>(可选): 这个元素的外键关键字段名
                        </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/2.png" alt="2" border="0"></td>
<td valign="top" align="left"><p>
                        <code class="literal">formula</code> (可选): 用于计算元素外键值的SQL公式.
                    </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/3.png" alt="3" border="0"></td>
<td valign="top" align="left"><p>
                            <code class="literal">class</code> (必需): 关联类的名称
                        </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/3.png" alt="3" border="0"></td>
<td valign="top" align="left"><p>
							<code class="literal">outer-join</code> (可选 - 默认为<code class="literal">auto</code>):
							在Hibernate系统参数中<code class="literal">hibernate.use_outer_join</code>被打开的情况下,该参数用来允许使用outer join来载入此集合的数据。
                        </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/4.png" alt="4" border="0"></td>
<td valign="top" align="left"><p>
                        为此关联打开外连接抓取或者后续select抓取。这是特殊情况；对于一个实体及其指向其他实体的多对多关联进全预先抓取（使用一条单独的<code class="literal">SELECT</code>)，你不仅需要对集合自身打开<code class="literal">join</code>，也需要对<code class="literal">&lt;many-to-many&gt;</code>这个内嵌元素打开此属性。
                    </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/5.png" alt="5" border="0"></td>
<td valign="top" align="left"><p>
                        对外键字段允许DDL生成的时候生成一个惟一约束。这使关联变成了一个高效的一对多关联。（此句存疑：原文为This makes the association multiplicity effectively one to many.)
                    </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/6.png" alt="6" border="0"></td>
<td valign="top" align="left"><p>
	                    <code class="literal">not-found</code> (可选 - 默认为 <code class="literal">exception</code>): 指明引用的外键中缺少某些行该如何处理：
	                    <code class="literal">ignore</code> 会把缺失的行作为一个空引用处理。
	                </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/7.png" alt="7" border="0"></td>
<td valign="top" align="left"><p>
                        <code class="literal">entity-name</code> (可选): 被关联的类的实体名，作为<code class="literal">class</code>的替代。
                    </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/8.png" alt="8" border="0"></td>
<td valign="top" align="left"><p>
                        <code class="literal">property-ref</code>: (可选) 被关联到此外键(foreign key)的类中的对应属性的名字。若未指定，使用被关联类的主键。
                    </p></td>
</tr>
</table></div>
</div>
<p>
                例子：首先, 一组字符串：
            </p>
<pre class="programlisting">&lt;set name="names" table="NAMES"&gt;
    &lt;key column="GROUPID"/&gt;
    &lt;element column="NAME" type="string"/&gt;
&lt;/set&gt;</pre>
<p>
                包含一组整数的bag(还设置了<code class="literal">order-by</code>参数指定了迭代的顺序)：
            </p>
<pre class="programlisting">&lt;bag name="sizes" 
        table="item_sizes" 
        order-by="size asc"&gt;
    &lt;key column="item_id"/&gt;
    &lt;element column="size" type="integer"/&gt;
&lt;/bag&gt;</pre>
<p>
                一个实体数组,在这个案例中是一个多对多的关联(注意这里的实体是自动管理生命周期的对象（lifecycle objects）,<code class="literal">cascade="all"</code>):
            </p>
<pre class="programlisting">&lt;array name="addresses" 
        table="PersonAddress" 
        cascade="persist"&gt;
    &lt;key column="personId"/&gt;
    &lt;list-index column="sortOrder"/&gt;
    &lt;many-to-many column="addressId" class="Address"/&gt;
&lt;/array&gt;</pre>
<p>
                一个map,通过字符串的索引来指明日期：
            </p>
<pre class="programlisting">&lt;map name="holidays" 
        table="holidays" 
        schema="dbo" 
        order-by="hol_name asc"&gt;
    &lt;key column="id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre>
<p>
                一个组件的列表：（下一章讨论）
            </p>
<pre class="programlisting">&lt;list name="carComponents" 
        table="CarComponents"&gt;
    &lt;key column="carId"/&gt;
    &lt;list-index column="sortOrder"/&gt;
    &lt;composite-element class="CarComponent"&gt;
        &lt;property name="price"/&gt;
        &lt;property name="type"/&gt;
        &lt;property name="serialNumber" column="serialNum"/&gt;
    &lt;/composite-element&gt;
&lt;/list&gt;</pre>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="collections-onetomany"></a>6.2.5.&#160;一对多关联（One-to-many Associations）</h3></div></div></div>
<p>
                <span class="emphasis"><em>一对多关联</em></span><span class="emphasis"><em>通过外键</em></span>连接两个类对应的表,而没有中间集合表。 这个关系模型失去了一些Java集合的语义:
            </p>
<div class="itemizedlist"><ul type="disc" compact>
<li><p>
                        一个被包含的实体的实例只能被包含在一个集合的实例中
                    </p></li>
<li><p>
                        一个被包含的实体的实例只能对应于集合索引的一个值中
                    </p></li>
</ul></div>
<p>
                一个从<code class="literal">Product</code>到<code class="literal">Part</code>的关联需要关键字字段,可能还有一个索引字段指向<code class="literal">Part</code>所对应的表。 <code class="literal">&lt;one-to-many&gt;</code>标记指明了一个一对多的关联。
            </p>
<div class="programlistingco">
<pre class="programlisting">&lt;one-to-many 
        class="ClassName"
        not-found="ignore|exception"
        entity-name="EntityName"
        node="element-name"
        embed-xml="true|false"
    /&gt;</pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td>
<td valign="top" align="left"><p>
                            <code class="literal">class</code>(必须):被关联类的名称。
                        </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/2.png" alt="2" border="0"></td>
<td valign="top" align="left"><p>
		                <code class="literal">not-found</code> (可选 - 默认为<code class="literal">exception</code>): 
		               指明若缓存的标示值关联的行缺失,该如何处理:
		                <code class="literal">ignore</code> 会把缺失的行作为一个空关联处理。
		            </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><img src="images/callouts/3.png" alt="3" border="0"></td>
<td valign="top" align="left"><p>
                        <code class="literal">entity-name</code> (可选): 被关联的类的实体名，作为<code class="literal">class</code>的替代。
                    </p></td>
</tr>
</table></div>
</div>
<p>
                例子
            </p>
<pre class="programlisting">&lt;set name="bars"&gt;
    &lt;key column="foo_id"/&gt;
    &lt;one-to-many class="org.hibernate.Bar"/&gt;
&lt;/set&gt;</pre>
<p>
                注意:<code class="literal">&lt;one-to-many&gt;</code>元素不需要定义任何字段。 也不需要指定表名。
                
            </p>
<p>
                <span class="emphasis"><em>重要提示</em></span>:如果<code class="literal">一对多</code>关联中的外键字段定义成<code class="literal">NOT NULL</code>,你必须把<code class="literal">&lt;key&gt;</code>映射声明为<code class="literal">not-null="true"</code>,或者使用<span class="emphasis"><em>双向关联</em></span>，并且标明<code class="literal">inverse="true"</code>。参阅本章后面关于双向关联的讨论。
            </p>
<p>
            下面的例子展示一个<code class="literal">Part</code>实体的map,把name作为关键字。(  <code class="literal">partName</code> 是<code class="literal">Part</code>的持久化属性)。注意其中的基于公式的索引的用法。
        </p>
<pre class="programlisting">&lt;map name="parts"
        cascade="all"&gt;
    &lt;key column="productId" not-null="true"/&gt;
    &lt;map-key formula="partName"/&gt;
    &lt;one-to-many class="Part"/&gt;
&lt;/map&gt;</pre>
</div>
</div></body>
</html>
