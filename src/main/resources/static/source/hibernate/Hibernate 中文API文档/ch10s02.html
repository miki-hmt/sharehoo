<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>10.2.&#160;使对象持久化</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="ch10.html" title="第&#160;10&#160;章&#160;与对象共事">
<link rel="prev" href="ch10.html" title="第&#160;10&#160;章&#160;与对象共事">
<link rel="next" href="ch10s03.html" title="10.3.&#160;装载对象">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="objectstate-makingpersistent"></a>10.2.&#160;使对象持久化</h2></div></div></div>
<p>
			Hibernate认为持久化类(persistent class)新实例化的对象是<span class="emphasis"><em>瞬时(Transient)</em></span>的。
			我们可通过将瞬时(Transient)对象与session关联而把它变为<span class="emphasis"><em>持久(Persistent)</em></span>的。
        </p>
<pre class="programlisting">DomesticCat fritz = new DomesticCat();
fritz.setColor(Color.GINGER);
fritz.setSex('M');
fritz.setName("Fritz");
Long generatedId = (Long) sess.save(fritz);</pre>
<p>
			如果<code class="literal">Cat</code>的持久化标识(identifier)是<code class="literal">generated</code>类型的，
			那么该标识(identifier)会自动在<code class="literal">save()</code>被调用时产生并分配给<code class="literal">cat</code>。
			如果<code class="literal">Cat</code>的持久化标识(identifier)是<code class="literal">assigned</code>类型的，或是一个复合主键(composite key)，
			那么该标识(identifier)应当在调用<code class="literal">save()</code>之前手动赋予给<code class="literal">cat</code>。
			你也可以按照EJB3 early draft中定义的语义，使用<code class="literal">persist()</code>替代<code class="literal">save()</code>。
        </p>
<p>
            此外，你可以用一个重载版本的<code class="literal">save()</code>方法。
        </p>
<pre class="programlisting">DomesticCat pk = new DomesticCat();
pk.setColor(Color.TABBY);
pk.setSex('F');
pk.setName("PK");
pk.setKittens( new HashSet() );
pk.addKitten(fritz);
sess.save( pk, new Long(1234) );</pre>
<p>
			如果你持久化的对象有关联的对象(associated objects)（例如上例中的<code class="literal">kittens</code>集合）
  			那么对这些对象（译注：pk和kittens）进行持久化的顺序是任意的（也就是说可以先对kittens进行持久化也可以先对pk进行持久化），
  			除非你在外键列上有<code class="literal">NOT NULL</code>约束。
            Hibernate不会违反外键约束，但是如果你用错误的顺序持久化对象（译注：在pk持久化之前持久化kitten），那么可能会违反<code class="literal">NOT NULL</code>约束。
        </p>
<p>
			通常你不会为这些细节烦心，因为你很可能会使用Hibernate的
			<span class="emphasis"><em>传播性持久化(transitive persistence)</em></span>功能自动保存相关联那些对象。
			这样连违反<code class="literal">NOT NULL</code>约束的情况都不会出现了 - Hibernate会管好所有的事情。
			传播性持久化(transitive persistence)将在本章稍后讨论。
        </p>
</div></body>
</html>
