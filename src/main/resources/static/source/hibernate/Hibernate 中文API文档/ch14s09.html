<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>14.9.&#160;表达式</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="ch14.html" title="第&#160;14&#160;章&#160;HQL: Hibernate查询语言">
<link rel="prev" href="ch14s08.html" title="14.8.&#160;where子句">
<link rel="next" href="ch14s10.html" title="14.10.&#160;order by子句">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="queryhql-expressions"></a>14.9.&#160;表达式</h2></div></div></div>
<p>
            在<code class="literal">where</code>子句中允许使用的表达式包括
            大多数你可以在SQL使用的表达式种类:
        </p>
<div class="itemizedlist"><ul type="disc" compact>
<li><p>
                    数学运算符<code class="literal">+, -, *, /</code>
                </p></li>
<li><p>
                    二进制比较运算符<code class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</code>
                </p></li>
<li><p>
                    逻辑运算符<code class="literal">and, or, not</code>
                </p></li>
<li><p>
                    <code class="literal">in</code>,
                    <code class="literal">not in</code>,
                    <code class="literal">between</code>,
                    <code class="literal">is null</code>,
                    <code class="literal">is not null</code>,
                    <code class="literal">is empty</code>,
                    <code class="literal">is not empty</code>,
                    <code class="literal">member of</code> and 
                    <code class="literal">not member of</code>
                </p></li>
<li><p>
                	"简单的" case, <code class="literal">case ... when ... then ... else ... end</code>,和
                    "搜索" case, <code class="literal">case when ... then ... else ... end</code> 
                </p></li>
<li><p>
                    字符串连接符<code class="literal">...||...</code> or <code class="literal">concat(...,...)</code>
                </p></li>
<li><p>
                    <code class="literal">current_date()</code>, <code class="literal">current_time()</code>,
                    <code class="literal">current_timestamp()</code>
                </p></li>
<li><p>
					<code class="literal">second(...)</code>, <code class="literal">minute(...)</code>, 
					<code class="literal">hour(...)</code>, <code class="literal">day(...)</code>, 
					<code class="literal">month(...)</code>, <code class="literal">year(...)</code>,
                </p></li>
<li><p>
                    EJB-QL 3.0定义的任何函数或操作：<code class="literal">substring(), trim(),
                    lower(), upper(), length(), locate(), abs(), sqrt(), bit_length()， mod()</code>
                </p></li>
<li><p>
                    <code class="literal">coalesce()</code> 和 <code class="literal">nullif()</code>
                </p></li>
<li><p>
                    <code class="literal">str()</code> 把数字或者时间值转换为可读的字符串
                </p></li>
<li><p>
                    <code class="literal">cast(... as ...)</code>, 其第二个参数是某Hibernate类型的名字，以及<code class="literal">extract(... from ...)</code>，只要ANSI 
                    <code class="literal">cast()</code> 和 <code class="literal">extract()</code> 被底层数据库支持
                </p></li>
<li><p>
                    HQL <code class="literal">index()</code> 函数，作用于join的有序集合的别名。
                    
                </p></li>
<li><p>
                    HQL函数，把集合作为参数:<code class="literal">size(), minelement(), maxelement(), minindex(), maxindex()</code>,还有特别的<code class="literal">elements()</code> 和<code class="literal">indices</code>函数，可以与数量词加以限定：<code class="literal">some, all, exists, any, in</code>。
                    
                </p></li>
<li><p>
                任何数据库支持的SQL标量函数，比如<code class="literal">sign()</code>, 
                    <code class="literal">trunc()</code>, <code class="literal">rtrim()</code>, <code class="literal">sin()</code>
                </p></li>
<li><p>
                    JDBC风格的参数传入 <code class="literal">?</code>
                </p></li>
<li><p>
                    命名参数<code class="literal">:name</code>, <code class="literal">:start_date</code>, <code class="literal">:x1</code>
                </p></li>
<li><p>
                    SQL 直接常量 <code class="literal">'foo'</code>, <code class="literal">69</code>, <code class="literal">6.66E+2</code>, <code class="literal">'1970-01-01 10:00:01.0'</code>
                </p></li>
<li><p>
                    Java <code class="literal">public static final</code> 类型的常量 <code class="literal">eg.Color.TABBY</code>
                </p></li>
</ul></div>
<p>
            关键字<code class="literal">in</code>与<code class="literal">between</code>可按如下方法使用:
        </p>
<pre class="programlisting">from DomesticCat cat where cat.name between 'A' and 'B'</pre>
<pre class="programlisting">from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )</pre>
<p>
            而且否定的格式也可以如下书写：
        </p>
<pre class="programlisting">from DomesticCat cat where cat.name not between 'A' and 'B'</pre>
<pre class="programlisting">from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )</pre>
<p>
            同样, 子句<code class="literal">is null</code>与<code class="literal">is not null</code>可以被用来测试空值(null).
        </p>
<p>
            在Hibernate配置文件中声明HQL“查询替代（query substitutions）”之后，
            布尔表达式（Booleans）可以在其他表达式中轻松的使用:
        </p>
<pre class="programlisting">&lt;property name="hibernate.query.substitutions"&gt;true 1, false 0&lt;/property&gt;</pre>
<p>
            系统将该HQL转换为SQL语句时，该设置表明将用字符 <code class="literal">1</code> 和  
<code class="literal">0</code> 来
            取代关键字<code class="literal">true</code> 和 <code class="literal">false</code>:

        </p>
<pre class="programlisting">from Cat cat where cat.alive = true</pre>
<p>
            你可以用特殊属性<code class="literal">size</code>, 或是特殊函数<code class="literal">size()</code>测试一个集合的大小。
        </p>
<pre class="programlisting">from Cat cat where cat.kittens.size &gt; 0</pre>
<pre class="programlisting">from Cat cat where size(cat.kittens) &gt; 0</pre>
<p>
            对于索引了（有序）的集合，你可以使用<code class="literal">minindex</code> 与 <code class="literal">maxindex</code>函数来引用到最小与最大的索引序数。
            同理，你可以使用<code class="literal">minelement</code> 与 <code class="literal">maxelement</code>函数来 
引用到一个基本数据类型的集合中最小与最大的元素。

        </p>
<pre class="programlisting">from Calendar cal where maxelement(cal.holidays) &gt; current_date</pre>
<pre class="programlisting">from Order order where maxindex(order.items) &gt; 100</pre>
<pre class="programlisting">from Order order where minelement(order.items) &gt; 10000</pre>
<p>
在传递一个集合的索引集或者是元素集(<code class="literal">elements</code>与<code class="literal">indices</code> 函数)
            或者传递一个子查询的结果的时候，可以使用SQL函数<code class="literal">any, some, all, exists, in</code>

        </p>
<pre class="programlisting">select mother from Cat as mother, Cat as kit
where kit in elements(foo.kittens)</pre>
<pre class="programlisting">select p from NameList list, Person p
where p.name = some elements(list.names)</pre>
<pre class="programlisting">from Cat cat where exists elements(cat.kittens)</pre>
<pre class="programlisting">from Player p where 3 &gt; all elements(p.scores)</pre>
<pre class="programlisting">from Show show where 'fizard' in indices(show.acts)</pre>
<p>
            注意，在Hibernate3种，这些结构变量- <code class="literal">size</code>, <code class="literal">elements</code>,
            <code class="literal">indices</code>, <code class="literal">minindex</code>, <code class="literal">maxindex</code>,
            <code class="literal">minelement</code>, <code class="literal">maxelement</code> - 只能在where子句中使用。
        </p>
<p>
            一个被索引过的（有序的）集合的元素(arrays, lists, maps)可以在其他索引中被引用（只能在where子句中）：
        </p>
<pre class="programlisting">from Order order where order.items[0].id = 1234</pre>
<pre class="programlisting">select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar</pre>
<pre class="programlisting">select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11</pre>
<pre class="programlisting">select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11</pre>
<p>
            在<code class="literal">[]</code>中的表达式甚至可以是一个算数表达式。
        </p>
<pre class="programlisting">select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item</pre>
<p>
            对于一个一对多的关联（one-to-many association）或是值的集合中的元素，
            HQL也提供内建的<code class="literal">index()</code>函数，
        </p>
<pre class="programlisting">select item, index(item) from Order order 
    join order.items item
where index(item) &lt; 5</pre>
<p>
            如果底层数据库支持标量的SQL函数，它们也可以被使用
        </p>
<pre class="programlisting">from DomesticCat cat where upper(cat.name) like 'FRI%'</pre>
<p>
            如果你还不能对所有的这些深信不疑，想想下面的查询。如果使用SQL，语句长度会增长多少，可读性会下降多少：
        </p>
<pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)</pre>
<p>
            <span class="emphasis"><em>提示:</em></span> 会像如下的语句
        </p>
<pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre>
</div></body>
</html>
