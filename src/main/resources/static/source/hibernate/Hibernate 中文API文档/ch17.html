<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>第&#160;17&#160;章&#160;过滤数据</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="prev" href="ch16s04.html" title="16.4.&#160;定制装载SQL">
<link rel="next" href="ch18.html" title="第&#160;18&#160;章&#160;XML映射">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title">
<a name="filters"></a>第&#160;17&#160;章&#160;过滤数据</h2></div></div></div>
<div class="toc">
<p><b>目录</b></p>
<dl><dt><span class="sect1"><a href="ch17.html#objectstate-filters">17.1. Hibernate 过滤器(filters)</a></span></dt></dl>
</div>
<p>

                Hibernate3 提供了一种创新的方式来处理具有“显性(visibility)”规则的数据，那就是使用<span class="emphasis"><em>Hibernate filter</em></span>。
                <span class="emphasis"><em>Hibernate filter</em></span>是全局有效的、具有名字、可以带参数的过滤器，
                对于某个特定的Hibernate session您可以选择是否启用（或禁用）某个过滤器。
    </p>
<div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="objectstate-filters"></a>17.1.&#160;Hibernate 过滤器(filters)</h2></div></div></div>
<p>
                        Hibernate3新增了对某个类或者集合使用预先定义的过滤器条件(filter criteria)的功能。过滤器条件相当于定义一个
                        非常类似于类和各种集合上的“where”属性的约束子句，但是过滤器条件可以带参数。
                        应用程序可以在运行时决定是否启用给定的过滤器，以及使用什么样的参数值。
                        过滤器的用法很像数据库视图，只不过是在应用程序中确定使用什么样的参数的。
                        
        </p>
<p>

            要使用过滤器，必须首先在相应的映射节点中定义。而定义一个过滤器，要用到位于<code class="literal">&lt;hibernate-mapping/&gt;</code>
			节点之内的<code class="literal">&lt;filter-def/&gt;</code>节点：
        </p>
<pre class="programlisting">&lt;filter-def name="myFilter"&gt;
    &lt;filter-param name="myFilterParam" type="string"/&gt;
&lt;/filter-def&gt;</pre>
<p>
			定义好之后，就可以在某个类中使用这个过滤器：
        </p>
<pre class="programlisting">&lt;class name="myClass" ...&gt;
    ...
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/class&gt;</pre>
<p>
			也可以在某个集合使用它：
        </p>
<pre class="programlisting">&lt;set ...&gt;
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/set&gt;</pre>
<p>
                        可以在多个类或集合中使用某个过滤器；某个类或者集合中也可以使用多个过滤器。
        </p>
<p>

			<code class="literal">Session</code>对象中会用到的方法有：<code class="literal">enableFilter(String filterName)</code>,
            <code class="literal">getEnabledFilter(String filterName)</code>, 和 <code class="literal">disableFilter(String filterName)</code>.
			Session中默认是<span class="emphasis"><em>不</em></span>启用过滤器的，必须通过<code class="literal">Session.enabledFilter()</code>方法显式的启用。
			该方法返回被启用的<code class="literal">Filter</code>的实例。以上文定义的过滤器为例：
        </p>
<pre class="programlisting">session.enableFilter("myFilter").setParameter("myFilterParam", "some-value");</pre>
<p>
			注意，org.hibernate.Filter的方法允许链式方法调用。（类似上面例子中启用Filter之后设定Filter参数这个“方法链”）
                        Hibernate的其他部分也大多有这个特性。
        </p>
<p>
			下面是一个比较完整的例子，使用了记录生效日期模式过滤有时效的数据：
        </p>
<pre class="programlisting">&lt;filter-def name="effectiveDate"&gt;
    &lt;filter-param name="asOfDate" type="date"/&gt;
&lt;/filter-def&gt;

&lt;class name="Employee" ...&gt;
...
    &lt;many-to-one name="department" column="dept_id" class="Department"/&gt;
    &lt;property name="effectiveStartDate" type="date" column="eff_start_dt"/&gt;
    &lt;property name="effectiveEndDate" type="date" column="eff_end_dt"/&gt;
...
    &lt;!--
        Note that this assumes non-terminal records have an eff_end_dt set to
        a max db date for simplicity-sake

		注意，为了简单起见，此处假设雇用关系生效期尚未结束的记录的eff_end_dt字段的值等于数据库最大的日期
    --&gt;
    &lt;filter name="effectiveDate"
            condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
&lt;/class&gt;

&lt;class name="Department" ...&gt;
...
    &lt;set name="employees" lazy="true"&gt;
        &lt;key column="dept_id"/&gt;
        &lt;one-to-many class="Employee"/&gt;
        &lt;filter name="effectiveDate"
                condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre>
<p>
			定义好后，如果想要保证取回的都是目前处于生效期的记录，只需在获取雇员数据的操作之前先开启过滤器即可：
        </p>
<pre class="programlisting">Session session = ...;
session.enabledFilter("effectiveDate").setParameter("asOfDate", new Date());
List results = session.createQuery("from Employee as e where e.salary &gt; :targetSalary")
         .setLong("targetSalary", new Long(1000000))
         .list();
</pre>
<p>

			在上面的HQL中，虽然我们仅仅显式的使用了一个薪水条件，但因为启用了过滤器，查询将仅返回那些目前雇用
			关系处于生效期的，并且薪水高于一百万美刀的雇员的数据。

        </p>
<p>

			注意：如果你打算在使用外连接（或者通过HQL或load fetching）的同时使用过滤器，要注意条件表达式的方向（左还是右）。
			最安全的方式是使用左外连接（left outer joining）。并且通常来说，先写参数，
			然后是操作符，最后写数据库字段名。
        </p>
<p>
            在Filter定义之后,它可能被附加到多个实体和/或集合类,每个都有自己的条件。假若这些条件都是一样的，每次都要定义就显得很繁琐。因此，<code class="literal">&lt;filter-def/&gt;</code>被用来定义一个默认条件，它可能作为属性或者CDATA出现：
        </p>
<pre class="programlisting">&lt;filter-def name="myFilter" condition="abc &gt; xyz"&gt;...&lt;/filter-def&gt;
&lt;filter-def name="myOtherFilter"&gt;abc=xyz&lt;/filter-def&gt;</pre>
<p>
        	当这个filter被附加到任何目的地，而又没有指明条件时，这个条件就会被使用。注意，换句话说，你可以通过给filter附加特别的条件来重载默认条件。
        </p>
</div>
</div></body>
</html>
