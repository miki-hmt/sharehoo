<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>14.15.&#160;小技巧 &amp; 小窍门</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="ch14.html" title="第&#160;14&#160;章&#160;HQL: Hibernate查询语言">
<link rel="prev" href="ch14s14.html" title="14.14.&#160;批量的UPDATE和DELETE">
<link rel="next" href="ch15.html" title="第&#160;15&#160;章&#160; 条件查询(Criteria Queries)">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="queryhql-tipstricks"></a>14.15.&#160;小技巧 &amp; 小窍门</h2></div></div></div>
<p>
            你可以统计查询结果的数目而不必实际的返回他们：
        </p>
<pre class="programlisting">( (Integer) session.iterate("select count(*) from ....").next() ).intValue()</pre>
<p>
            若想根据一个集合的大小来进行排序，可以使用如下的语句：
        </p>
<pre class="programlisting">select usr.id, usr.name
from User as usr 
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)</pre>
<p>
            如果你的数据库支持子选择，你可以在你的查询的where子句中为选择的大小（selection size）指定一个条件:
        </p>
<pre class="programlisting">from User usr where size(usr.messages) &gt;= 1</pre>
<p>
            如果你的数据库不支持子选择语句，使用下面的查询：
        </p>
<pre class="programlisting">select usr.id, usr.name
from User usr.name
    join usr.messages msg
group by usr.id, usr.name
having count(msg) &gt;= 1</pre>
<p>
            因为内连接（inner join）的原因，这个解决方案不能返回含有零个信息的<code class="literal">User</code>
            类的实例, 所以这种情况下使用下面的格式将是有帮助的:
        </p>
<pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0</pre>
<p>
            JavaBean的属性可以被绑定到一个命名查询（named query）的参数上：
        </p>
<pre class="programlisting">Query q = s.createQuery("from foo Foo as foo where foo.name=:name and foo.size=:size");
q.setProperties(fooBean); // fooBean包含方法getName()与getSize()
List foos = q.list();</pre>
<p>
            通过将接口<code class="literal">Query</code>与一个过滤器（filter）一起使用，集合（Collections）是可以分页的：
        </p>
<pre class="programlisting">Query q = s.createFilter( collection, "" ); // 一个简单的过滤器
q.setMaxResults(PAGE_SIZE);
q.setFirstResult(PAGE_SIZE * pageNumber);
List page = q.list();</pre>
<p>
            通过使用查询过滤器（query filter）可以将集合（Collection）的原素分组或排序:
        </p>
<pre class="programlisting">Collection orderedCollection = s.filter( collection, "order by this.amount" );
Collection counts = s.filter( collection, "select this.type, count(this) group by this.type" );</pre>
<p>
            不用通过初始化，你就可以知道一个集合（Collection）的大小：
        </p>
<pre class="programlisting">( (Integer) session.iterate("select count(*) from ....").next() ).intValue();</pre>
</div></body>
</html>
