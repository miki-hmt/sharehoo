<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>4.4.&#160;动态模型(Dynamic models)</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="ch04.html" title="第&#160;4&#160;章&#160;持久化类(Persistent Classes)">
<link rel="prev" href="ch04s03.html" title="4.3.&#160;实现equals()和hashCode()">
<link rel="next" href="ch04s05.html" title="4.5.&#160;元组片断映射(Tuplizers)">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="persistent-classes-dynamicmodels"></a>4.4.&#160;动态模型(Dynamic models)</h2></div></div></div>
<p>
						<span class="emphasis"><em>注意，以下特性在当前处于试验阶段，将来可能会有变化。</em></span>
				</p>
<p>
						运行期的持久化实体没有必要一定表示为像POJO类或JavaBean对象那样的形式。Hibernate也支持动态模型
						（在运行期使用<code class="literal">Map</code>的<code class="literal">Map</code>）和象DOM4J的树模型那
						样的实体表示。使用这种方法，你不用写持久化类，只写映射文件就行了。
				</p>
<p>
						Hibernate默认工作在普通POJO模式。你可以使用配置选项<code class="literal">default_entity_mode</code>，
						对特定的<code class="literal">SessionFactory</code>，设置一个默认的实体表示模式。
						（参见<a href="ch03s04.html#configuration-optional-properties" title="表&#160;3.3.&#160;
                Hibernate配置属性
            ">表&#160;3.3 “
                Hibernate配置属性
            ”</a>。）
				</p>
<p>
						下面是用<code class="literal">Map</code>来表示的例子。首先，在映射文件中，要声明
						<code class="literal">entity-name</code>来代替一个类名（或作为一种附属）。
				</p>
<pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class entity-name="Customer"&gt;

        &lt;id name="id"
            type="long"
            column="ID"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;

        &lt;property name="name"
            column="NAME"
            type="string"/&gt;

        &lt;property name="address"
            column="ADDRESS"
            type="string"/&gt;

        &lt;many-to-one name="organization"
            column="ORGANIZATION_ID"
            class="Organization"/&gt;

        &lt;bag name="orders"
            inverse="true"
            lazy="false"
            cascade="all"&gt;
            &lt;key column="CUSTOMER_ID"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/bag&gt;

    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</pre>
<p>
						注意，虽然是用目标类名来声明关联的，但是关联的目标类型除了是POJO之外，也可以
						是一个动态的实体。
				</p>
<p>
						在使用<code class="literal">dynamic-map</code>为<code class="literal">SessionFactory</code>
						设置了默认的实体模式之后，可以在运行期使用<code class="literal">Map</code>的
						<code class="literal">Map</code>。
				</p>
<pre class="programlisting">Session s = openSession();
Transaction tx = s.beginTransaction();
Session s = openSession();

// Create a customer
Map david = new HashMap();
david.put("name", "David");

// Create an organization
Map foobar = new HashMap();
foobar.put("name", "Foobar Inc.");

// Link both
david.put("organization", foobar);

// Save both
s.save("Customer", david);
s.save("Organization", foobar);

tx.commit();
s.close();</pre>
<p>
						动态映射的好处是，变化所需要的时间少了，因为原型不需要实现实体类。然而，你无法进行
						编译期的类型检查，并可能由此会处理很多的运行期异常。幸亏有了Hibernate映射，它使得数
						据库的schema能容易的规格化和合理化，并允许稍后在此之上添加合适的领域模型实现。
				</p>
<p>
						实体表示模式也能在每个<code class="literal">Session</code>的基础上设置：
				</p>
<pre class="programlisting">Session dynamicSession = pojoSession.getSession(EntityMode.MAP);

// Create a customer
Map david = new HashMap();
david.put("name", "David");
dynamicSession.save("Customer", david);
...
dynamicSession.flush();
dynamicSession.close()
...
// Continue on pojoSession
</pre>
<p>
						请注意，用<code class="literal">EntityMode</code>调用<code class="literal">getSession()</code>是在
						<code class="literal">Session</code>的API中，而不是<code class="literal">SessionFactory</code>。
						这样，新的<code class="literal">Session</code>共享底层的JDBC连接，事务，和其他的上下文信
						息。这意味着，你不需要在第二个<code class="literal">Session</code>中调用
						<code class="literal">flush()</code>和<code class="literal">close()</code>，同样的，把事务和连接的处理
						交给原来的工作单元。
				</p>
<p>
						关于XML表示能力的更多信息可以在<a href="ch18.html" title="第&#160;18&#160;章&#160;XML映射">第&#160;18&#160;章 <i>XML映射</i></a>中找到。
				</p>
</div></body>
</html>
