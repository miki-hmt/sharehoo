<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>1.3.&#160; 第二部分 － 关联映射</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="ch01.html" title="第&#160;1&#160;章&#160; Hibernate入门">
<link rel="prev" href="ch01s02.html" title="1.2.&#160; 第一部分 － 第一个Hibernate应用程序">
<link rel="next" href="ch01s04.html" title="1.4.&#160;第三部分 - EventManager web应用程序">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="tutorial-associations"></a>1.3.&#160;
	第二部分 － 关联映射
	</h2></div></div></div>
<p>
	我们已经映射了一个持久化实体类到表上。让我们在这个基础上增加一些类之间的关联。首先我们往应用程序里增加人（people）的概念，并存储他们所参与的一个Event列表。（译者注：与Event一样，我们在后面将直接使用person来表示“人”而不是它的中文翻译）
        </p>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="tutorial-associations-mappinguser"></a>1.3.1.&#160;
	映射Person类
		</h3></div></div></div>
<p>
	最初简单的<code class="literal">Person</code>类：
            </p>
<pre class="programlisting">package events;

public class Person {

    private Long id;
    private int age;
    private String firstname;
    private String lastname;

    public Person() {}

    // Accessor methods for all properties, private setter for 'id'

}</pre>
<p>
                创建一个名为<code class="literal">Person.hbm.xml</code>的新映射文件（别忘了最上面的DTD引用）：
            </p>
<pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="events.Person" table="PERSON"&gt;
        &lt;id name="id" column="PERSON_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="age"/&gt;
        &lt;property name="firstname"/&gt;
        &lt;property name="lastname"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre>
<p>
                最后，把新的映射加入到Hibernate的配置中：
            </p>
<pre class="programlisting">&lt;mapping resource="events/Event.hbm.xml"/&gt;
&lt;mapping resource="events/Person.hbm.xml"/&gt;</pre>
<p>
	现在我们在这两个实体之间创建一个关联。显然，persons可以参与一系列events，而events也有不同的参加者（persons）。我们需要处理的设计问题是关联方向（directionality），阶数（multiplicity）和集合（collection）的行为。
            </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="tutorial-associations-unidirset"></a>1.3.2.&#160;
	单向Set-based的关联
		</h3></div></div></div>
<p>
	我们将向<code class="literal">Person</code>类增加一连串的events。那样，通过调用<code class="literal">aPerson.getEvents()</code>，就可以轻松地导航到特定person所参与的events，而不用去执行一个显式的查询。我们使用Java的集合类（collection）：<code class="literal">Set</code>，因为set 不包含重复的元素及与我们无关的排序。
            </p>
<p>
	我们需要用set 实现一个单向多值关联。让我们在Java类里为这个关联编码，接着映射它：
            </p>
<pre class="programlisting">public class Person {

    private Set events = new HashSet();

    public Set getEvents() {
        return events;
    }

    public void setEvents(Set events) {
        this.events = events;
    }
}</pre>
<p>
	在映射这个关联之前，先考虑一下此关联的另外一端。很显然，我们可以保持这个关联是单向的。或者，我们可以在<code class="literal">Event</code>里创建另外一个集合，如果希望能够双向地导航，如：<code class="literal">anEvent.getParticipants()</code>。从功能的角度来说，这并不是必须的。因为你总可以显式地执行一个查询，以获得某个特定event的所有参与者。这是个在设计时需要做出的选择，完全由你来决定，但此讨论中关于关联的阶数是清楚的：即两端都是“多”值的，我们把它叫做<span class="emphasis"><em>多对多(many-to-many)</em></span>关联。因而，我们使用Hibernate的多对多映射：
            </p>
<pre class="programlisting">&lt;class name="events.Person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="age"/&gt;
    &lt;property name="firstname"/&gt;
    &lt;property name="lastname"/&gt;

    &lt;set name="events" table="PERSON_EVENT"&gt;
        &lt;key column="PERSON_ID"/&gt;
        &lt;many-to-many column="EVENT_ID" class="events.Event"/&gt;
    &lt;/set&gt;

&lt;/class&gt;</pre>
<p>
	Hibernate支持各种各样的集合映射，<code class="literal">&lt;set&gt;</code>使用的最为普遍。对于多对多关联（或叫<span class="emphasis"><em>n:m</em></span>实体关系）, 需要一个关联表（association table）。<code class="literal">表</code>里面的每一行代表从person到event的一个关联。表名是由<code class="literal">set</code>元素的<code class="literal">table</code>属性配置的。关联里面的标识符字段名，对于person的一端，是由<code class="literal">&lt;key&gt;</code>元素定义，而event一端的字段名是由<code class="literal">&lt;many-to-many&gt;</code>元素的<code class="literal">column</code>属性定义。你也必须告诉Hibernate集合中对象的类（也就是位于这个集合所代表的关联另外一端的类）。
            </p>
<p>
	 因而这个映射的数据库schema是：
            </p>
<pre class="programlisting">
    _____________        __________________
   |             |      |                  |       _____________
   |   EVENTS    |      |   PERSON_EVENT   |      |             |
   |_____________|      |__________________|      |    PERSON   |
   |             |      |                  |      |_____________|
   | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |
   |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  |
   |  TITLE      |      |__________________|      |  AGE        |
   |_____________|                                |  FIRSTNAME  |
                                                  |  LASTNAME   |
                                                  |_____________|
 </pre>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="tutorial-associations-working"></a>1.3.3.&#160;
	使关联工作
	</h3></div></div></div>
<p>
	我们把一些people和events 一起放到<code class="literal">EventManager</code>的新方法中：
            </p>
<pre class="programlisting">private void addPersonToEvent(Long personId, Long eventId) {

    Session session = HibernateUtil.getSessionFactory().getCurrentSession();
    session.beginTransaction();

    Person aPerson = (Person) session.load(Person.class, personId);
    Event anEvent = (Event) session.load(Event.class, eventId);

    aPerson.getEvents().add(anEvent);

    session.getTransaction().commit();
}</pre>
<p>
	在加载一<code class="literal">Person</code>和<code class="literal">Event</code>后，使用普通的集合方法就可容易地修改我们定义的集合。如你所见，没有显式的<code class="literal">update()</code>或<code class="literal">save()</code>，Hibernate会自动检测到集合已经被修改并需要更新回数据库。这叫做自动脏检查（<span class="emphasis"><em>automatic dirty checking</em></span>），你也可以尝试修改任何对象的name或者date属性，只要他们处于<span class="emphasis"><em>持久化</em></span>状态，也就是被绑定到某个Hibernate 的<code class="literal">Session</code>上（如：他们刚刚在一个单元操作被加载或者保存），Hibernate监视任何改变并在后台隐式写的方式执行SQL。同步内存状态和数据库的过程，通常只在单元操作结束的时候发生，称此过程为清理缓存<span class="emphasis"><em>（flushing）</em></span>。在我们的代码中，工作单元由数据库事务的提交（或者回滚）来结束――这是由<code class="literal">CurrentSessionContext</code>类的<code class="literal">thread</code>配置选项定义的。
            </p>
<p>
	当然，你也可以在不同的单元操作里面加载person和event。或在<code class="literal">Session</code>以外修改不是处在持久化（persistent）状态下的对象（如果该对象以前曾经被持久化，那么我们称这个状态为<span class="emphasis"><em>脱管（detached）</em></span>）。你甚至可以在一个集合被脱管时修改它：
            </p>
<pre class="programlisting">private void addPersonToEvent(Long personId, Long eventId) {

    Session session = HibernateUtil.getSessionFactory().getCurrentSession();
    session.beginTransaction();

    Person aPerson = (Person) session
            .createQuery("select p from Person p left join fetch p.events where p.id = :pid")
            .setParameter("pid", personId)
            .uniqueResult(); // Eager fetch the collection so we can use it detached

    Event anEvent = (Event) session.load(Event.class, eventId);

    session.getTransaction().commit();

    // End of first unit of work

    aPerson.getEvents().add(anEvent); // aPerson (and its collection) is detached

    // Begin second unit of work

    Session session2 = HibernateUtil.getSessionFactory().getCurrentSession();
    session2.beginTransaction();

    session2.update(aPerson); // Reattachment of aPerson

    session2.getTransaction().commit();
}</pre>
<p>
	对<code class="literal">update</code>的调用使一个脱管对象重新持久化，你可以说它被绑定到一个新的单元操作上，所以在脱管状态下对它所做的任何修改都会被保存到数据库里。这也包括你对这个实体对象的集合所作的任何改动（增加/删除）。
            </p>
<p>
	这对我们当前的情形不是很有用，但它是非常重要的概念，你可以把它融入到你自己的应用程序设计中。在<code class="literal">EventManager</code>的main方法中添加一个新的动作，并从命令行运行它来完成我们所做的练习。如果你需要person及event的标识符 ― 那就用<code class="literal">save()</code>方法返回它（你可能需要修改前面的一些方法来返回那个标识符）：
            </p>
<pre class="programlisting">else if (args[0].equals("addpersontoevent")) {
    Long eventId = mgr.createAndStoreEvent("My Event", new Date());
    Long personId = mgr.createAndStorePerson("Foo", "Bar");
    mgr.addPersonToEvent(personId, eventId);
    System.out.println("Added person " + personId + " to event " + eventId);
}</pre>
<p>
	上面是个关于两个同等重要的实体类间关联的例子。像前面所提到的那样，在特定的模型中也存在其它的类和类型，这些类和类型通常是“次要的”。你已看到过其中的一些，像<code class="literal">int</code>或<code class="literal">String</code>。我们称这些类为<span class="emphasis"><em>值类型（value type）</em></span>，它们的实例<span class="emphasis"><em>依赖（depend）</em></span>在某个特定的实体上。这些类型的实例没有它们自己的标识（identity），也不能在实体间被共享（比如，两个person不能引用同一个<code class="literal">firstname</code>对象，即使他们有相同的first name）。当然，值类型并不仅仅在JDK中存在（事实上，在一个Hibernate应用程序中，所有的JDK类都被视为值类型），而且你也可以编写你自己的依赖类，例如<code class="literal">Address</code>，<code class="literal">MonetaryAmount</code>。
            </p>
<p>
	你也可以设计一个值类型的集合，这在概念上与引用其它实体的集合有很大的不同，但是在Java里面看起来几乎是一样的。
            </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="tutorial-associations-valuecollections"></a>1.3.4.&#160;
	值类型的集合
	</h3></div></div></div>
<p>
	我们把一个值类型对象的集合加入<code class="literal">Person</code>实体中。我们希望保存email地址，所以使用<code class="literal">String</code>类型，而且这次的集合类型又是<code class="literal">Set</code>：
            </p>
<pre class="programlisting">private Set emailAddresses = new HashSet();

public Set getEmailAddresses() {
    return emailAddresses;
}

public void setEmailAddresses(Set emailAddresses) {
    this.emailAddresses = emailAddresses;
}</pre>
<p>
	这个<code class="literal">Set</code>的映射
            </p>
<pre class="programlisting">&lt;set name="emailAddresses" table="PERSON_EMAIL_ADDR"&gt;
    &lt;key column="PERSON_ID"/&gt;
    &lt;element type="string" column="EMAIL_ADDR"/&gt;
&lt;/set&gt;</pre>
<p>
	比较这次和此前映射的差别，主要在于<code class="literal">element</code>部分，这次并没有包含对其它实体引用的集合，而是元素类型为<code class="literal">String</code>的集合（在映射中使用小写的名字”string“是向你表明它是一个Hibernate的映射类型或者类型转换器）。和之前一样，<code class="literal">set</code>元素的<code class="literal">table</code>属性决定了用于集合的表名。<code class="literal">key</code>元素定义了在集合表中外键的字段名。<code class="literal">element</code>元素的<code class="literal">column</code>属性定义用于实际保存<code class="literal">String</code>值的字段名。
            </p>
<p>
	看一下修改后的数据库schema。
            </p>
<pre class="programlisting">
  _____________        __________________
 |             |      |                  |       _____________
 |   EVENTS    |      |   PERSON_EVENT   |      |             |       ___________________
 |_____________|      |__________________|      |    PERSON   |      |                   |
 |             |      |                  |      |_____________|      | PERSON_EMAIL_ADDR |
 | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |      |___________________|
 |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  | &lt;--&gt; |  *PERSON_ID       |
 |  TITLE      |      |__________________|      |  AGE        |      |  *EMAIL_ADDR      |
 |_____________|                                |  FIRSTNAME  |      |___________________|
                                                |  LASTNAME   |
                                                |_____________|
 </pre>
<p>
	你可以看到集合表的主键实际上是个复合主键，同时使用了2个字段。这也暗示了对于同一个person不能有重复的email地址，这正是Java里面使用Set时候所需要的语义（Set里元素不能重复）。
            </p>
<p>
	你现在可以试着把元素加入到这个集合，就像我们在之前关联person和event的那样。其实现的Java代码是相同的：
            </p>
<pre class="programlisting">private void addEmailToPerson(Long personId, String emailAddress) {

    Session session = HibernateUtil.getSessionFactory().getCurrentSession();
    session.beginTransaction();

    Person aPerson = (Person) session.load(Person.class, personId);

    // The getEmailAddresses() might trigger a lazy load of the collection
    aPerson.getEmailAddresses().add(emailAddress);

    session.getTransaction().commit();
}</pre>
<p>
                这次我们没有使用<span class="emphasis"><em>fetch</em></span>查询来初始化集合。因此，调用其getter方法会触发另一附加的select来初始化集合，这样我们才能把元素添加进去。检查SQL log，试着通过预先抓取来优化它。
            </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="tutorial-associations-bidirectional"></a>1.3.5.&#160;
	双向关联
	</h3></div></div></div>
<p>
	接下来我们将映射双向关联（bi-directional association）－ 在Java里让person和event可以从关联的任何一端访问另一端。当然，数据库schema没有改变，我们仍然需要多对多的阶数。一个关系型数据库要比网络编程语言	更加灵活，所以它并不需要任何像导航方向（navigation direction）的东西 － 数据可以用任何可能的方式进行查看和获取。
            </p>
<p>
	首先，把一个参与者（person）的集合加入<code class="literal">Event</code>类中：
            </p>
<pre class="programlisting">private Set participants = new HashSet();

public Set getParticipants() {
    return participants;
}

public void setParticipants(Set participants) {
    this.participants = participants;
}</pre>
<p>
	在<code class="literal">Event.hbm.xml</code>里面也映射这个关联。
            </p>
<pre class="programlisting">&lt;set name="participants" table="PERSON_EVENT" inverse="true"&gt;
    &lt;key column="EVENT_ID"/&gt;
    &lt;many-to-many column="PERSON_ID" class="events.Person"/&gt;
&lt;/set&gt;</pre>
<p>
	如你所见，两个映射文件里都有普通的<code class="literal">set</code>映射。注意在两个映射文件中，互换了<code class="literal">key</code>和<code class="literal">many-to-many</code>的字段名。这里最重要的是<code class="literal">Event</code>映射文件里增加了<code class="literal">set</code>元素的<code class="literal">inverse="true"</code>属性。
            </p>
<p>
	这意味着在需要的时候，Hibernate能在关联的另一端 － <code class="literal">Person</code>类得到两个实体间关联的信息。这将会极大地帮助你理解双向关联是如何在两个实体间被创建的。
            </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="tutorial-associations-usingbidir"></a>1.3.6.&#160;
	使双向连起来
	</h3></div></div></div>
<p>
	首先请记住，Hibernate并不影响通常的Java语义。	在单向关联的例子中，我们是怎样在<code class="literal">Person</code>和<code class="literal">Event</code>之间创建联系的？我们把<code class="literal">Event</code>实例添加到<code class="literal">Person</code>实例内的event引用集合里。因此很显然，如果我们要让这个关联可以双向地工作，我们需要在另外一端做同样的事情 － 把<code class="literal">Person</code>实例加入<code class="literal">Event</code>类内的Person引用集合。这“在关联的两端设置联系”是完全必要的而且你都得这么做。
            </p>
<p>
	许多开发人员防御式地编程，创建管理关联的方法来保证正确的设置了关联的两端，比如在<code class="literal">Person</code>里：
            </p>
<pre class="programlisting">protected Set getEvents() {
    return events;
}

protected void setEvents(Set events) {
    this.events = events;
}

public void addToEvent(Event event) {
    this.getEvents().add(event);
    event.getParticipants().add(this);
}

public void removeFromEvent(Event event) {
    this.getEvents().remove(event);
    event.getParticipants().remove(this);
}</pre>
<p>
	注意现在对于集合的get和set方法的访问级别是protected - 这允许在位于同一个包（package）中的类以及继承自这个类的子类可以访问这些方法，但禁止其他任何人的直接访问，避免了集合内容的混乱。你应尽可能地在另一端也把集合的访问级别设成protected。
            </p>
<p>
	<code class="literal">inverse</code>映射属性究竟表示什么呢？对于你和Java来说，一个双向关联仅仅是在两端简单地正确设置引用。然而，Hibernate并没有足够的信息去正确地执行<code class="literal">INSERT</code>和<code class="literal">UPDATE</code>语句（以避免违反数据库约束），所以它需要一些帮助来正确的处理双向关联。把关联的一端设置为<code class="literal">inverse</code>将告诉Hibernate忽略关联的这一端，把这端看成是另外一端的一个<span class="emphasis"><em>镜象（mirror）</em></span>。这就是所需的全部信息，Hibernate利用这些信息来处理把一个有向导航模型转移到数据库schema时的所有问题。你只需要记住这个直观的规则：所有的双向关联需要有一端被设置为<code class="literal">inverse</code>。在一对多关联中它必须是代表多（many）的那端。而在多对多（many-to-many）关联中，你可以任意选取一端，因为两端之间并没有差别。
            </p>
</div>
<p>
	让我们把进入一个小型的web应用程序。
        </p>
</div></body>
</html>
