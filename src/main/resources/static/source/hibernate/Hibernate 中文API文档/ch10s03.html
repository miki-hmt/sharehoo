<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>10.3.&#160;装载对象</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="ch10.html" title="第&#160;10&#160;章&#160;与对象共事">
<link rel="prev" href="ch10s02.html" title="10.2.&#160;使对象持久化">
<link rel="next" href="ch10s04.html" title="10.4.&#160;查询">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="objectstate-loading"></a>10.3.&#160;装载对象</h2></div></div></div>
<p>
        	如果你知道某个实例的持久化标识(identifier)，你就可以使用<code class="literal">Session</code>的<code class="literal">load()</code>方法
        	来获取它。 <code class="literal">load()</code>的另一个参数是指定类的.class对象。
        	本方法会创建指定类的持久化实例，并从数据库加载其数据(state)。
        </p>
<pre class="programlisting">Cat fritz = (Cat) sess.load(Cat.class, generatedId);</pre>
<pre class="programlisting">// you need to wrap primitive identifiers
long id = 1234;
DomesticCat pk = (DomesticCat) sess.load( DomesticCat.class, new Long(id) );</pre>
<p>
            此外, 你可以把数据(state)加载到指定的对象实例上（覆盖掉该实例原来的数据）。
        </p>
<pre class="programlisting">Cat cat = new DomesticCat();
// load pk's state into cat
sess.load( cat, new Long(pkId) );
Set kittens = cat.getKittens();</pre>
<p>
			请注意如果没有匹配的数据库记录，<code class="literal">load()</code>方法可能抛出无法恢复的异常(unrecoverable exception)。
			如果类的映射使用了代理(proxy)，<code class="literal">load()</code>方法会返回一个未初始化的代理，直到你调用该代理的某方法时才会去访问数据库。
			若你希望在某对象中创建一个指向另一个对象的关联，又不想在从数据库中装载该对象时同时装载相关联的那个对象，那么这种操作方式就用得上的了。
			如果为相应类映射关系设置了<code class="literal">batch-size</code>，
			那么使用这种操作方式允许多个对象被一批装载（因为返回的是代理，无需从数据库中抓取所有对象的数据）。
        </p>
<p>
       		如果你不确定是否有匹配的行存在，应该使用<code class="literal">get()</code>方法，它会立刻访问数据库，如果没有对应的记录，会返回null。
        </p>
<pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id);
if (cat==null) {
    cat = new Cat();
    sess.save(cat, id);
}
return cat;</pre>
<p>
			你甚至可以选用某个<code class="literal">LockMode</code>，用SQL的<code class="literal">SELECT ... FOR UPDATE</code>装载对象。
			请查阅API文档以获取更多信息。
        </p>
<pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);</pre>
<p>
              注意，任何关联的对象或者包含的集合都<span class="emphasis"><em>不会</em></span>被以<code class="literal">FOR UPDATE</code>方式返回，
 			除非你指定了<code class="literal">lock</code>或者<code class="literal">all</code>作为关联(association)的级联风格(cascade style)。
        </p>
<p>
			任何时候都可以使用<code class="literal">refresh()</code>方法强迫装载对象和它的集合。如果你使用数据库触发器功能来处理对象的某些属性，这个方法就很有用了。
        </p>
<pre class="programlisting">sess.save(cat);
sess.flush(); //force the SQL INSERT
sess.refresh(cat); //re-read the state (after the trigger executes)</pre>
<p>
			此处通常会出现一个重要问题: Hibernate会从数据库中装载多少东西？会执行多少条相应的SQL<code class="literal">SELECT</code>语句？
           	这取决于<span class="emphasis"><em>抓取策略(fetching strategy)</em></span>，会在<a href="ch19.html#performance-fetching" title="19.1.&#160;
			抓取策略(Fetching strategies)
		">第&#160;19.1&#160;节 “
			抓取策略(Fetching strategies)
		”</a>中解释。
        </p>
</div></body>
</html>
