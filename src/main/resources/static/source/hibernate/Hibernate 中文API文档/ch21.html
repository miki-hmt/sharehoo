<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>第&#160;21&#160;章&#160;示例：父子关系(Parent Child Relationships)</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="prev" href="ch20.html" title="第&#160;20&#160;章&#160;工具箱指南">
<link rel="next" href="ch21s02.html" title="21.2.&#160;双向的一对多关系(Bidirectional one-to-many)">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title">
<a name="example-parentchild"></a>第&#160;21&#160;章&#160;示例：父子关系(Parent Child Relationships)</h2></div></div></div>
<div class="toc">
<p><b>目录</b></p>
<dl>
<dt><span class="sect1"><a href="ch21.html#example-parentchild-collections">21.1. 关于collections需要注意的一点</a></span></dt>
<dt><span class="sect1"><a href="ch21s02.html">21.2. 双向的一对多关系(Bidirectional one-to-many)</a></span></dt>
<dt><span class="sect1"><a href="ch21s03.html">21.3. 级联生命周期（Cascading lifecycle）</a></span></dt>
<dt><span class="sect1"><a href="ch21s04.html">21.4. 级联与<code class="literal">未保存值</code>（Cascades and <code class="literal">unsaved-value</code>）</a></span></dt>
<dt><span class="sect1"><a href="ch21s05.html">21.5. 结论</a></span></dt>
</dl>
</div>
<p>
    刚刚接触Hibernate的人大多是从父子关系（parent / child type relationship）的建模入手的。父子关系的建模有两种方法。由于种种原因，最方便的方法是把<code class="literal">Parent</code>和<code class="literal">Child</code>都建模成实体类，并创建一个从<code class="literal">Parent</code>指向<code class="literal">Child</code>的&lt;one-to-many&gt;关联，对新手来说尤其如此。还有一种方法，就是将<code class="literal">Child</code>声明为一个<code class="literal">&lt;composite-element&gt;</code>（组合元素）。 事实上在Hibernate中one to many关联的默认语义远没有composite element贴近parent / child关系的通常语义。下面我们会阐述如何使用<span class="emphasis"><em>带有级联的双向一对多关联(bidirectional one to many association with cascades)</em></span>去建立有效、优美的parent / child关系。这一点也不难！
    </p>
<div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="example-parentchild-collections"></a>21.1.&#160;关于collections需要注意的一点</h2></div></div></div>
<p>    
        Hibernate collections被当作其所属实体而不是其包含实体的一个逻辑部分。这非常重要！它主要体现为以下几点：
    </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
            当删除或增加collection中对象的时候，collection所属者的版本值会递增。
        </p></li>
<li><p>
	    如果一个从collection中移除的对象是一个值类型(value type)的实例，比如composite element，那么这个对象的持久化状态将会终止，其在数据库中对应的记录会被删除。同样的，向collection增加一个value type的实例将会使之立即被持久化。
        </p></li>
<li><p>
            另一方面，如果从一对多或多对多关联的collection中移除一个实体，在缺省情况下这个对象并不会被删除。这个行为是完全合乎逻辑的－－改变一个实体的内部状态不应该使与它关联的实体消失掉！同样的，向collection增加一个实体不会使之被持久化。
        </p></li>
</ul></div>
<p>
        实际上，向Collection增加一个实体的缺省动作只是在两个实体之间创建一个连接而已，同样移除的时候也只是删除连接。这种处理对于所有的情况都是合适的。对于父子关系则是完全不适合的，在这种关系下，子对象的生存绑定于父对象的生存周期。
    </p>
</div>
</div></body>
</html>
