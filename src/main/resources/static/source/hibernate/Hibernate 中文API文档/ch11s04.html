<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>11.4.&#160;悲观锁定(Pessimistic Locking)</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="ch11.html" title="第&#160;11&#160;章&#160;事务和并发">
<link rel="prev" href="ch11s03.html" title="11.3.&#160;乐观并发控制(Optimistic concurrency control)">
<link rel="next" href="ch11s05.html" title="11.5.&#160;连接释放模式(Connection Release Modes)">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="transactions-locking"></a>11.4.&#160;悲观锁定(Pessimistic Locking)</h2></div></div></div>
<p>
           用户其实并不需要花很多精力去担心锁定策略的问题。通常情况下，只要为JDBC连接指定一下隔
           离级别，然后让数据库去搞定一切就够了。然而，高级用户有时候希望进行一个排它的悲观锁定，
           或者在一个新的事务启动的时候，重新进行锁定。
        </p>
<p>
            Hibernate总是使用数据库的锁定机制，从不在内存中锁定对象！
        </p>
<p>
            类<code class="literal">LockMode</code> 定义了Hibernate所需的不同的锁定级别。一个锁定
            可以通过以下的机制来设置:
        </p>
<div class="itemizedlist"><ul type="disc" compact>
<li><p>
                    当Hibernate更新或者插入一行记录的时候，锁定级别自动设置为<code class="literal">LockMode.WRITE</code>。
                </p></li>
<li><p>
                    当用户显式的使用数据库支持的SQL格式<code class="literal">SELECT ... FOR UPDATE</code> 
                    发送SQL的时候，锁定级别设置为<code class="literal">LockMode.UPGRADE</code> 
                </p></li>
<li><p>
                    当用户显式的使用Oracle数据库的SQL语句<code class="literal">SELECT ... FOR UPDATE NOWAIT</code>
                    的时候，锁定级别设置<code class="literal">LockMode.UPGRADE_NOWAIT</code> 
                </p></li>
<li><p>
                    当Hibernate在“可重复读”或者是“序列化”数据库隔离级别下读取数据的时候，锁定模式
                    自动设置为<code class="literal">LockMode.READ</code>。这种模式也可以通过用户显式指定进行设置。
                </p></li>
<li><p>
						<code class="literal">LockMode.NONE</code> 代表无需锁定。在<code class="literal">Transaction</code>结束时，
						所有的对象都切换到该模式上来。与session相关联的对象通过调用<code class="literal">update()</code>
						或者<code class="literal">saveOrUpdate()</code>脱离该模式。
        </p></li>
</ul></div>
<p>
            "显式的用户指定"可以通过以下几种方式之一来表示:
        </p>
<div class="itemizedlist"><ul type="disc" compact>
<li><p>
                    调用 <code class="literal">Session.load()</code>的时候指定<code class="literal">锁定模式(LockMode)</code>。
                </p></li>
<li><p>
                    调用<code class="literal">Session.lock()</code>。
                </p></li>
<li><p>
                    调用<code class="literal">Query.setLockMode()</code>。
                </p></li>
</ul></div>
<p>
           如果在<code class="literal">UPGRADE</code>或者<code class="literal">UPGRADE_NOWAIT</code>锁定模式下调
           用<code class="literal">Session.load()</code>，并且要读取的对象尚未被session载入过，那么对象
           通过<code class="literal">SELECT ... FOR UPDATE</code>这样的SQL语句被载入。如果为一个对象调用
           <code class="literal">load()</code>方法时，该对象已经在另一个较少限制的锁定模式下被载入了，那
           么Hibernate就对该对象调用<code class="literal">lock()</code> 方法。
        </p>
<p>
            如果指定的锁定模式是<code class="literal">READ</code>, <code class="literal">UPGRADE</code> 或
            <code class="literal">UPGRADE_NOWAIT</code>，那么<code class="literal">Session.lock()</code>就
            执行版本号检查。（在<code class="literal">UPGRADE</code> 或者<code class="literal">UPGRADE_NOWAIT</code>
            锁定模式下，执行<code class="literal">SELECT ... FOR UPDATE</code>这样的SQL语句。）
        </p>
<p>
           如果数据库不支持用户设置的锁定模式，Hibernate将使用适当的替代模式（而不是扔出异常）。
           这一点可以确保应用程序的可移植性。
        </p>
</div></body>
</html>
