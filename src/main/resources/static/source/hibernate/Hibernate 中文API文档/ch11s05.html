<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>11.5.&#160;连接释放模式(Connection Release Modes)</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="ch11.html" title="第&#160;11&#160;章&#160;事务和并发">
<link rel="prev" href="ch11s04.html" title="11.4.&#160;悲观锁定(Pessimistic Locking)">
<link rel="next" href="ch12.html" title="第&#160;12&#160;章&#160; 拦截器与事件(Interceptors and events)">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="transactions-connection-release"></a>11.5.&#160;连接释放模式(Connection Release Modes)</h2></div></div></div>
<p>
            Hibernate关于JDBC连接管理的旧(2.x)行为是，<code class="literal">Session</code>在第一次需要的时候获取一个连接，在session关闭之前一直会持有这个连接。Hibernate引入了连接释放的概念，来告诉session如何处理它的JDBC连接。注意，下面的讨论只适用于采用配置<code class="literal">ConnectionProvider</code>来提供连接的情况，用户自己提供的连接与这里的讨论无关。通过<code class="literal">org.hibernate.ConnectionReleaseMode</code>的不同枚举值来使用不用的释放模式:
            
        </p>
<div class="itemizedlist"><ul type="disc" compact>
<li><p>
                    <code class="literal">ON_CLOSE</code> - 基本上就是上面提到的老式行为。Hibernate session在第一次需要进行JDBC操作的时候获取连接，然后持有它，直到session关闭。
                </p></li>
<li><p>
                    <code class="literal">AFTER_TRANSACTION</code> - 在<code class="literal">org.hibernate.Transaction</code>结束后释放连接。
                </p></li>
<li><p>
                    <code class="literal">AFTER_STATEMENT</code> (也被称做积极释放) - 在每一条语句被执行后就释放连接。但假若语句留下了与session相关的资源，那就不会被释放。目前唯一的这种情形就是使用<code class="literal">org.hibernate.ScrollableResults</code>。
                </p></li>
</ul></div>
<p>
            <code class="literal">hibernate.connection.release_mode</code>配置参数用来指定使用哪一种释放模式。可能的值有：
        </p>
<div class="itemizedlist"><ul type="disc" compact>
<li><p>
                    <code class="literal">auto</code>(默认) - 这一选择把释放模式委派给<code class="literal">org.hibernate.transaction.TransactionFactory.getDefaultReleaseMode()</code>方法。对JTATransactionFactory来说，它会返回ConnectionReleaseMode.AFTER_STATEMENT;对JDBCTransactionFactory来说，则是ConnectionReleaseMode.AFTER_TRANSACTION。很少需要修改这一默认行为，因为假若设置不当，就会带来bug，或者给用户代码带来误导。
                </p></li>
<li><p>
                    <code class="literal">on_close</code> - 使用 ConnectionReleaseMode.ON_CLOSE.  这种方式是为了向下兼容的,但是已经完全不被鼓励使用了。
                </p></li>
<li><p>
                    <code class="literal">after_transaction</code> - 使用ConnectionReleaseMode.AFTER_TRANSACTION。这一设置不应该在JTA环境下使用。也要注意，使用ConnectionReleaseMode.AFTER_TRANSACTION的时候，假若session 处于auto-commit状态，连接会像AFTER_STATEMENT那样被释放。
                </p></li>
<li><p>
                    <code class="literal">after_statement</code> - 使用ConnectionReleaseMode.AFTER_STATEMENT。除此之外，会查询配置的<code class="literal">ConnectionProvider</code>，是否它支持这一设置（(<code class="literal">supportsAggressiveRelease()</code>)）。假若不支持，释放模式会被设置为ConnectionReleaseMode.AFTER_TRANSACTION。只有在你每次调用<code class="literal">ConnectionProvider.getConnection()</code>获取底层JDBC连接的时候，都可以确信获得同一个连接的时候，这一设置才是安全的；或者在auto-commit环境中，你可以不管是否每次都获得同一个连接的时候，这才是安全的。
                    
                </p></li>
</ul></div>
</div></body>
</html>
