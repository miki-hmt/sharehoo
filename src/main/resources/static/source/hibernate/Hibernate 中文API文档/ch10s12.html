<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>10.12.&#160;使用元数据</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="ch10.html" title="第&#160;10&#160;章&#160;与对象共事">
<link rel="prev" href="ch10s11.html" title="10.11.&#160;传播性持久化(transitive persistence)">
<link rel="next" href="ch11.html" title="第&#160;11&#160;章&#160;事务和并发">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="objectstate-metadata"></a>10.12.&#160;使用元数据</h2></div></div></div>
<p>
            Hibernate中有一个非常丰富的元级别(meta-level)的模型，含有所有的实体和值类型数据的元数据。
              有时这个模型对应用程序本身也会非常有用。
              比如说，应用程序可能在实现一种“智能”的深度拷贝算法时，
              通过使用Hibernate的元数据来了解哪些对象应该被拷贝（比如，可变的值类型数据），
              那些不应该（不可变的值类型数据，也许还有某些被关联的实体）。
        </p>
<p>
            Hibernate提供了<code class="literal">ClassMetadata</code>接口，<code class="literal">CollectionMetadata</code>接口和<code class="literal">Type</code>层次体系来访问元数据。
              可以通过<code class="literal">SessionFactory</code>获取元数据接口的实例。
        </p>
<pre class="programlisting">Cat fritz = ......;
ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);

Object[] propertyValues = catMeta.getPropertyValues(fritz);
String[] propertyNames = catMeta.getPropertyNames();
Type[] propertyTypes = catMeta.getPropertyTypes();

// get a Map of all properties which are not collections or associations
Map namedValues = new HashMap();
for ( int i=0; i&lt;propertyNames.length; i++ ) {
    if ( !propertyTypes[i].isEntityType() &amp;&amp; !propertyTypes[i].isCollectionType() ) {
        namedValues.put( propertyNames[i], propertyValues[i] );
    }
}</pre>
</div></body>
</html>
