<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>第&#160;16&#160;章&#160;Native SQL查询</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="prev" href="ch15s09.html" title="15.9.&#160;根据自然标识查询(Queries by natural identifier)">
<link rel="next" href="ch16s02.html" title="16.2.&#160;命名SQL查询">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title">
<a name="querysql"></a>第&#160;16&#160;章&#160;Native SQL查询</h2></div></div></div>
<div class="toc">
<p><b>目录</b></p>
<dl>
<dt><span class="sect1"><a href="ch16.html#querysql-creating">16.1. 使用<code class="literal">SQLQuery</code></a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="ch16.html#id530151">16.1.1. 标量查询（Scalar queries）</a></span></dt>
<dt><span class="sect2"><a href="ch16.html#id530325">16.1.2. 实体查询(Entity queries)</a></span></dt>
<dt><span class="sect2"><a href="ch16.html#id530441">16.1.3. 处理关联和集合类(Handling associations and collections)</a></span></dt>
<dt><span class="sect2"><a href="ch16.html#id530542">16.1.4. 返回多个实体(Returning multiple entities)</a></span></dt>
<dt><span class="sect2"><a href="ch16.html#id531006">16.1.5. 返回非受管实体(Returning non-managed entities)</a></span></dt>
<dt><span class="sect2"><a href="ch16.html#id531071">16.1.6. 处理继承（Handling inheritance）</a></span></dt>
<dt><span class="sect2"><a href="ch16.html#id531088">16.1.7. 参数（Parameters）</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="ch16s02.html">16.2. 命名SQL查询</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="ch16s02.html#propertyresults">16.2.1. 使用return-property来明确地指定字段/别名</a></span></dt>
<dt><span class="sect2"><a href="ch16s02.html#sp_query">16.2.2. 使用存储过程来查询</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="ch16s03.html">16.3. 定制SQL用来create，update和delete</a></span></dt>
<dt><span class="sect1"><a href="ch16s04.html">16.4. 定制装载SQL</a></span></dt>
</dl>
</div>
<p>
		你也可以使用你的数据库的Native SQL语言来查询数据。这对你在要使用数据库的某些特性的时候(比如说在查询提示或者Oracle中的
		<code class="literal">CONNECT</code>关键字)，这是非常有用的。这就能够扫清你把原来直接使用SQL/JDBC 的程序迁移到基于
		Hibernate应用的道路上的障碍。
    </p>
<p>
		Hibernate3允许你使用手写的sql来完成所有的create,update,delete,和load操作（包括存储过程）
    </p>
<div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="querysql-creating"></a>16.1.&#160;使用<code class="literal">SQLQuery</code></h2></div></div></div>
<p>对原生SQL查询执行的控制是通过<code class="literal">SQLQuery</code>接口进行的，通过执行<code class="literal">Session.createSQLQuery()</code>获取这个接口。下面来描述如何使用这个API进行查询。</p>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="id530151"></a>16.1.1.&#160;标量查询（Scalar queries）</h3></div></div></div>
<p>
      最基本的SQL查询就是获得一个标量（数值）的列表。      </p>
<pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS").list();
sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE FROM CATS").list();
</pre>
<p>
      它们都将返回一个Object数组(Object[])组成的List，数组每个元素都是CATS表的一个字段值。Hibernate会使用ResultSetMetadata来判定返回的标量值的实际顺序和类型。
      </p>
<p>
      如果要避免过多的使用<code class="literal">ResultSetMetadata</code>,或者只是为了更加明确的指名返回值，可以使用<code class="literal">addScalar()</code>。
      </p>
<pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS")
 .addScalar("ID", Hibernate.LONG)
 .addScalar("NAME", Hibernate.STRING)
 .addScalar("BIRTHDATE", Hibernate.DATE)
</pre>
<p>这个查询指定了:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>SQL查询字符串</p></li>
<li><p>要返回的字段和类型</p></li>
</ul></div>
<p>
      它仍然会返回Object数组,但是此时不再使用<code class="literal">ResultSetMetdata</code>,而是明确的将ID,NAME和BIRTHDATE按照Long,String和Short类型从resultset中取出。同时，也指明了就算query是使用<code class="literal">*</code>来查询的，可能获得超过列出的这三个字段，也仅仅会返回这三个字段。
      </p>
<p>
      对全部或者部分的标量值不设置类型信息也是可以的。
      </p>
<pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS")
 .addScalar("ID", Hibernate.LONG)
 .addScalar("NAME")
 .addScalar("BIRTHDATE")
</pre>
<p>
      基本上这和前面一个查询相同,只是此时使用<code class="literal">ResultSetMetaData</code>来决定NAME和BIRTHDATE的类型，而ID的类型是明确指出的。
      </p>
<p>
      关于从ResultSetMetaData返回的java.sql.Types是如何映射到Hibernate类型，是由方言(Dialect)控制的。假若某个指定的类型没有被映射，或者不是你所预期的类型，你可以通过Dialet的<code class="literal">registerHibernateType</code>调用自行定义。
      </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="id530325"></a>16.1.2.&#160;实体查询(Entity queries)</h3></div></div></div>
<p>
      上面的查询都是返回标量值的，也就是从resultset中返回的“裸”数据。下面展示如何通过<code class="literal">addEntity()</code>让原生查询返回实体对象。
      </p>
<pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS").addEntity(Cat.class);
sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE FROM CATS").addEntity(Cat.class);
</pre>
<p>这个查询指定：</p>
<div class="itemizedlist"><ul type="disc">
<li><p>SQL查询字符串</p></li>
<li><p>要返回的实体</p></li>
</ul></div>
<p>
      假设Cat被映射为拥有ID,NAME和BIRTHDATE三个字段的类，以上的两个查询都返回一个List，每个元素都是一个Cat实体。
      </p>
<p>      
      假若实体在映射时有一个<code class="literal">many-to-one</code>的关联指向另外一个实体，在查询时必须也返回那个实体，否则会导致发生一个"column not found"的数据库错误。这些附加的字段可以使用*标注来自动返回，但我们希望还是明确指明，看下面这个具有指向<code class="literal">Dog</code>的<code class="literal">many-to-one</code>的例子：
      </p>
<pre class="programlisting">sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS").addEntity(Cat.class);
</pre>
<p>
      这样cat.getDog()就能正常运作。
      </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="id530441"></a>16.1.3.&#160;处理关联和集合类(Handling associations and collections)</h3></div></div></div>
<p>      
      通过提前抓取将<code class="literal">Dog</code>连接获得，而避免初始化proxy带来的额外开销也是可能的。这是通过<code class="literal">addJoin()</code>方法进行的，这个方法可以让你将关联或集合连接进来。
      </p>
<pre class="programlisting">sess.createSQLQuery("SELECT c.ID, NAME, BIRTHDATE, DOG_ID, D_ID, D_NAME FROM CATS c, DOGS d WHERE c.DOG_ID = d.D_ID")
 .addEntity("cat", Cat.class)
 .addJoin("cat.dog");
</pre>
<p>
            上面这个例子中，返回的<code class="literal">Cat</code>对象，其<code class="literal">dog</code>属性被完全初始化了，不再需要数据库的额外操作。注意，我们加了一个别名("cat")，以便指明join的目标属性路径。通过同样的提前连接也可以作用于集合类，例如，假若<code class="literal">Cat</code>有一个指向<code class="literal">Dog</code>的一对多关联。
      </p>
<pre class="programlisting">sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, CAT_ID FROM CATS c, DOGS d WHERE c.ID = d.CAT_ID")
 .addEntity("cat", Cat.class)
 .addJoin("cat.dogs");
</pre>
<font color="red">&lt;p&gt;
      到此为止，我们碰到了天花板：若不对SQL查询进行增强，这些已经是在Hibernate中使用原生SQL查询所能做到的最大可能了。下面的问题即将出现：返回多个同样类型的实体怎么办？或者默认的别名/字段不够又怎么办？
      
      &lt;/p&gt;</font>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="id530542"></a>16.1.4.&#160;返回多个实体(Returning multiple entities)</h3></div></div></div>
<p>
      到目前为止,结果集字段名被假定为和映射文件中指定的的字段名是一致的。假若SQL查询连接了多个表，同一个字段名可能在多个表中出现多次，这就会造成问题。
      </p>
<p>
      下面的查询中需要使用字段别名注射（这个例子本身会失败）：
      </p>
<pre class="programlisting">sess.createSQLQuery("SELECT c.*, m.*  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID")
 .addEntity("cat", Cat.class)
 .addEntity("mother", Cat.class)
</pre>
<p>
      这个查询的本意是希望每行返回两个Cat实例，一个是cat,另一个是它的妈妈。但是因为它们的字段名被映射为相同的，而且在某些数据库中，返回的字段别名是“c.ID”,"c.NAME"这样的形式，而它们和在映射文件中的名字（"ID"和"NAME"）不匹配，这就会造成失败。
      
      </p>
<p>
      下面的形式可以解决字段名重复：
      </p>
<pre class="programlisting">sess.createSQLQuery("SELECT {cat.*}, {mother.*}  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID")
 .addEntity("cat", Cat.class)
 .addEntity("mother", Cat.class)
</pre>
<p>这个查询指明：</p>
<div class="itemizedlist"><ul type="disc">
<li><p>
          SQL查询语句，其中包含占位附来让Hibernate注射字段别名</p></li>
<li><p>
          查询返回的实体
          </p></li>
</ul></div>
<p>
      上面使用的{cat.*}和{mother.*}标记是作为“所有属性”的简写形式出现的。当然你也可以明确地罗列出字段名，但在这个例子里面我们让Hibernate来为每个属性注射SQL字段别名。字段别名的占位符是属性名加上表别名的前缀。在下面的例子中，我们从另外一个表（cat_log）中通过映射元数据中的指定获取Cat和它的妈妈。注意，要是我们愿意，我们甚至可以在where子句中使用属性别名。
      
      </p>
<pre class="programlisting">String sql = "SELECT ID as {c.id}, NAME as {c.name}, " + 
         "BIRTHDATE as {c.birthDate}, MOTHER_ID as {c.mother}, {mother.*} " +
         "FROM CAT_LOG c, CAT_LOG m WHERE {c.mother} = c.ID";

List loggedCats = sess.createSQLQuery(sql)
        .addEntity("cat", Cat.class)
        .addEntity("mother", Cat.class).list()
</pre>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="querysql-aliasreferences"></a>16.1.4.1.&#160;别名和属性引用(Alias and property references)</h4></div></div></div>
<p>
        大多数情况下，都需要上面的属性注射，但在使用更加复杂的映射，比如复合属性、通过标识符构造继承树，以及集合类等等情况下，也有一些特别的别名，来允许Hibernate注射合适的别名。
        </p>
<p>
    下表列出了使用别名注射参数的不同可能性。注意：下面结果中的别名只是示例，实用时每个别名需要唯一并且不同的名字。
    </p>
<div class="table">
<a name="aliasinjection-summary"></a><p class="title"><b>表&#160;16.1.&#160;别名注射(alias injection names)</b></p>
<div class="table-contents"><table summary="别名注射(alias injection names)" border="1">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>描述</th>
<th>语法</th>
<th>示例</th>
</tr></thead>
<tbody>
<tr>
<td>简单属性</td>
<td><code class="literal">{[aliasname].[propertyname]</code></td>
<td><code class="literal">A_NAME as {item.name}</code></td>
</tr>
<tr>
<td>复合属性</td>
<td><code class="literal">{[aliasname].[componentname].[propertyname]}</code></td>
<td><code class="literal">CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}</code></td>
</tr>
<tr>
<td>实体辨别器(Discriminator of an entity)</td>
<td><code class="literal">{[aliasname].class}</code></td>
<td><code class="literal">DISC as {item.class}</code></td>
</tr>
<tr>
<td>实体的所有属性</td>
<td><code class="literal">{[aliasname].*}</code></td>
<td><code class="literal">{item.*}</code></td>
</tr>
<tr>
<td>集合键(collection key)</td>
<td><code class="literal">{[aliasname].key}</code></td>
<td><code class="literal">ORGID as {coll.key}</code></td>
</tr>
<tr>
<td>集合id</td>
<td><code class="literal">{[aliasname].id}</code></td>
<td><code class="literal">EMPID as {coll.id}</code></td>
</tr>
<tr>
<td>集合元素</td>
<td><code class="literal">{[aliasname].element}</code></td>
<td><code class="literal">XID as {coll.element}</code></td>
<td>&#160;</td>
</tr>
<tr>
<td>集合元素的属性</td>
<td><code class="literal">{[aliasname].element.[propertyname]}</code></td>
<td><code class="literal">NAME as {coll.element.name}</code></td>
<td class="auto-generated">&#160;</td>
</tr>
<tr>
<td>集合元素的所有属性</td>
<td><code class="literal">{[aliasname].element.*}</code></td>
<td><code class="literal">{coll.element.*}</code></td>
<td class="auto-generated">&#160;</td>
</tr>
<tr>
<td>集合的所有属性</td>
<td><code class="literal">{[aliasname].*}</code></td>
<td><code class="literal">{coll.*}</code></td>
<td class="auto-generated">&#160;</td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break">
</div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="id531006"></a>16.1.5.&#160;返回非受管实体(Returning non-managed entities)</h3></div></div></div>
<p>
      可以对原生sql 查询使用ResultTransformer。这会返回不受Hibernate管理的实体。
      
      </p>
<pre class="programlisting">sess.createSQLQuery("SELECT NAME, BIRTHDATE FROM CATS")
        .setResultTransformer(Transformers.aliasToBean(CatDTO.class))</pre>
<p>这个查询指定：</p>
<div class="itemizedlist"><ul type="disc">
<li><p>SQL查询字符串</p></li>
<li><p>结果转换器(result transformer)</p></li>
</ul></div>
<p>
        上面的查询将会返回<code class="literal">CatDTO</code>的列表,它将被实例化并且将NAME和BIRTHDAY的值注射入对应的属性或者字段。
        </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="id531071"></a>16.1.6.&#160;处理继承（Handling inheritance）</h3></div></div></div>
<p>
      原生SQL查询假若其查询结果实体是继承树中的一部分，它必须包含基类和所有子类的所有属性。
      </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="id531088"></a>16.1.7.&#160;参数（Parameters）</h3></div></div></div>
<p>
      原生查询支持位置参数和命名参数：
      </p>
<pre class="programlisting">Query query = sess.createSQLQuery("SELECT * FROM CATS WHERE NAME like ?").addEntity(Cat.class);
List pusList = query.setString(0, "Pus%").list();
     
query = sess.createSQLQuery("SELECT * FROM CATS WHERE NAME like :name").addEntity(Cat.class);
List pusList = query.setString("name", "Pus%").list();          </pre>
</div>
</div>
</div></body>
</html>
