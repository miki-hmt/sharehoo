<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>19.4.&#160;查询缓存（The Query Cache）</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="ch19.html" title="第&#160;19&#160;章&#160;提升性能">
<link rel="prev" href="ch19s03.html" title="19.3.&#160; 管理缓存（Managing the caches）">
<link rel="next" href="ch19s05.html" title="19.5.&#160; 理解集合性能（Understanding Collection performance）">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="performance-querycache"></a>19.4.&#160;查询缓存（The Query Cache）
		</h2></div></div></div>
<p>
			查询的结果集也可以被缓存。只有当经常使用同样的参数进行查询时，这才会有些用处。
			要使用查询缓存，首先你必须打开它：			
        </p>
<pre class="programlisting">hibernate.cache.use_query_cache true</pre>
<p>
			
			该设置将会创建两个缓存区域 - 一个用于保存查询结果集(<code class="literal">org.hibernate.cache.StandardQueryCache</code>)；
			另一个则用于保存最近查询的一系列表的时间戳(<code class="literal">org.hibernate.cache.UpdateTimestampsCache</code>)。
			请注意：在查询缓存中，它并不缓存结果集中所包含的实体的确切状态；它只缓存这些实体的标识符属性的值、以及各值类型的结果。
			所以查询缓存通常会和二级缓存一起使用。 
        </p>
<p>
			
			绝大多数的查询并不能从查询缓存中受益，所以Hibernate默认是不进行查询缓存的。如若需要进行缓存，请调用
			<code class="literal">Query.setCacheable(true)</code>方法。这个调用会让查询在执行过程中时先从缓存中查找结果，
			并将自己的结果集放到缓存中去。 
        </p>
<p>

			如果你要对查询缓存的失效政策进行精确的控制，你必须调用<code class="literal">Query.setCacheRegion()</code>方法，
			为每个查询指定其命名的缓存区域。 
        </p>
<pre class="programlisting">List blogs = sess.createQuery("from Blog blog where blog.blogger = :blogger")
    .setEntity("blogger", blogger)
    .setMaxResults(15)
    .setCacheable(true)
    .setCacheRegion("frontpages")
    .list();</pre>
<p>
			如果查询需要强行刷新其查询缓存区域，那么你应该调用<code class="literal">Query.setCacheMode(CacheMode.REFRESH)</code>方法。
			这对在其他进程中修改底层数据（例如，不通过Hibernate修改数据），或对那些需要选择性更新特定查询结果集的情况特别有用。
			这是对<code class="literal">SessionFactory.evictQueries()</code>的更为有效的替代方案，同样可以清除查询缓存区域。
        </p>
</div></body>
</html>
