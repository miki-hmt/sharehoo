<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>4.3.&#160;实现equals()和hashCode()</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="ch04.html" title="第&#160;4&#160;章&#160;持久化类(Persistent Classes)">
<link rel="prev" href="ch04s02.html" title="4.2.&#160;实现继承（Inheritance）">
<link rel="next" href="ch04s04.html" title="4.4.&#160;动态模型(Dynamic models)">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="persistent-classes-equalshashcode"></a>4.3.&#160;实现<code class="literal">equals()</code>和<code class="literal">hashCode()</code></h2></div></div></div>
<p>
            如果你有如下需求，你必须重载
            <code class="literal">equals()</code> 和 <code class="literal">hashCode()</code>方法：
        </p>
<div class="itemizedlist"><ul type="disc" compact>
<li><p> 
										想把持久类的实例放入<code class="literal">Set</code>中（当表示多值关联时，推荐这么做）										
								</p></li>
<li><p>
                		想重用脱管实例
                </p></li>
</ul></div>
<p>
						Hibernate保证，仅在特定会话范围内，持久化标识（数据库的行）和Java标识是等价的。因此，一旦
						我们混合了从不同会话中获取的实例，如果希望<code class="literal">Set</code>有明确的语义，就必
						须实现<code class="literal">equals()</code> 和<code class="literal">hashCode()</code>。
				</p>
<p>
						实现<code class="literal">equals()</code>/<code class="literal">hashCode()</code>最显而易见的方法是比较两个对象
						标识符的值。如果值相同，则两个对象对应于数据库的同一行，因此它们是相等的（如果都被添加到
						<code class="literal">Set</code>，则在<code class="literal">Set</code>中只有一个元素）。不幸的是，对生成的标识不能
						使用这种方法。Hibernate仅对那些持久化对象赋标识值，一个新创建的实例将不会有任何标识值。此外，
						如果一个实例没有被保存(unsaved)，并且它当前正在一个<code class="literal">Set</code>中，保存它将会给这个对象
						赋一个标识值。如果<code class="literal">equals()</code> 和 <code class="literal">hashCode()</code>是基于标识值
						实现的，则其哈希码将会改变，这违反了<code class="literal">Set</code>的契约。建议去Hibernate的站点阅读关于这个
						问题的全部讨论。注意，这不是Hibernate的问题，而是一般的Java对象标识和Java对象等价的语义问题。
				</p>
<p>
						我们建议使用<span class="emphasis"><em>业务键值相等(Business key equality)</em></span>来实现<code class="literal">equals()</code>
						和 <code class="literal">hashCode()</code>。业务键值相等的意思是，<code class="literal">equals()</code>方法
						仅仅比较形成业务键的属性，它能在现实世界里标识我们的实例（是一个<span class="emphasis"><em>自然的</em></span>候选码）。
				</p>
<pre class="programlisting">public class Cat {

    ...
    public boolean equals(Object other) {
        if (this == other) return true;
        if ( !(other instanceof Cat) ) return false;

        final Cat cat = (Cat) other;

        if ( !cat.getLitterId().equals( getLitterId() ) ) return false;
        if ( !cat.getMother().equals( getMother() ) ) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = getMother().hashCode();
        result = 29 * result + getLitterId();
        return result;
    }

}</pre>
<p>
						注意，业务键不必像数据库的主键那样固定不变（参见<a href="ch11.html#transactions-basics-identity" title="11.1.3.&#160;关注对象标识(Considering object identity)">第&#160;11.1.3&#160;节 “关注对象标识(Considering object identity)”</a>）。
						对业务键而言，不可变或唯一的属性是不错的选择。
				</p>
</div></body>
</html>
