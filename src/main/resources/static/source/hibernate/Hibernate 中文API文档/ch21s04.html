<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>21.4.&#160;级联与未保存值（Cascades and unsaved-value）</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="ch21.html" title="第&#160;21&#160;章&#160;示例：父子关系(Parent Child Relationships)">
<link rel="prev" href="ch21s03.html" title="21.3.&#160;级联生命周期（Cascading lifecycle）">
<link rel="next" href="ch21s05.html" title="21.5.&#160;结论">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="example-parentchild-update"></a>21.4.&#160;级联与<code class="literal">未保存值</code>（Cascades and <code class="literal">unsaved-value</code>）</h2></div></div></div>
<p>
         假设我们从<code class="literal">Session</code>中装入了一个<code class="literal">Parent</code>对象，用户界面对其进行了修改，然后希望在一个新的Session里面调用<code class="literal">update()</code>来保存这些修改。对象<code class="literal">Parent</code>包含了子对象的集合，由于打开了级联更新，Hibernate需要知道哪些Child对象是新实例化的，哪些代表数据库中已经存在的记录。我们假设<code class="literal">Parent</code>和<code class="literal">Child</code>对象的标识属性都是自动生成的，类型为<code class="literal">java.lang.Long</code>。Hibernate会使用标识属性的值，和version 或 timestamp 属性，来判断哪些子对象是新的。(参见<a href="ch10s07.html" title="10.7.&#160;自动状态检测">第&#160;10.7&#160;节 “自动状态检测”</a>.) <span class="emphasis"><em>在 Hibernate3 中,显式指定<code class="literal">unsaved-value</code>不再是必须的了。</em></span>
     </p>
<p>
         下面的代码会更新<code class="literal">parent</code>和<code class="literal">child</code>对象，并且插入<code class="literal">newChild</code>对象。
     </p>
<pre class="programlisting">//parent and child were both loaded in a previous session
parent.addChild(child);
Child newChild = new Child();
parent.addChild(newChild);
session.update(parent);
session.flush();</pre>
<p>
             Well, that's all very well for the case of a generated identifier, but what about assigned identifiers
             and composite identifiers? This is more difficult, since Hibernate can't use the identifier property to
             distinguish between a newly instantiated object (with an identifier assigned by the user) and an 
             object loaded in a previous session. In this case, Hibernate will either use the timestamp or version 
             property, or will actually query the second-level cache or, worst case, the database, to see if the 
             row exists.
         </p>
<p>
         这对于自动生成标识的情况是非常好的，但是自分配的标识和复合标识怎么办呢？这是有点麻烦，因为Hibernate没有办法区分新实例化的对象（标识被用户指定了）和前一个Session装入的对象。在这种情况下，Hibernate会使用timestamp或version属性，或者查询第二级缓存，或者最坏的情况，查询数据库，来确认是否此行存在。</p>
</div></body>
</html>
