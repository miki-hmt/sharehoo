<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>10.6.&#160;修改脱管(Detached)对象</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="ch10.html" title="第&#160;10&#160;章&#160;与对象共事">
<link rel="prev" href="ch10s05.html" title="10.5.&#160;修改持久对象">
<link rel="next" href="ch10s07.html" title="10.7.&#160;自动状态检测">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="objectstate-detached"></a>10.6.&#160;修改脱管(Detached)对象</h2></div></div></div>
<p>
            很多程序需要在某个事务中获取对象，然后将对象发送到界面层去操作，最后在一个新的事务保存所做的修改。
            在高并发访问的环境中使用这种方式，通常使用附带版本信息的数据来保证这些“长“工作单元之间的隔离。
        </p>
<p>
        	Hibernate通过提供<code class="literal">Session.update()</code>或<code class="literal">Session.merge()</code>
        	重新关联脱管实例的办法来支持这种模型。
        </p>
<pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catId);
Cat potentialMate = new Cat();
firstSession.save(potentialMate);

// in a higher layer of the application
cat.setMate(potentialMate);

// later, in a new session
secondSession.update(cat);  // update cat
secondSession.update(mate); // update mate</pre>
<p>
            如果具有<code class="literal">catId</code>持久化标识的<code class="literal">Cat</code>之前已经被<code class="literal">另一Session(secondSession)</code>装载了，
            应用程序进行重关联操作(reattach)的时候会抛出一个异常。
        </p>
<p>
        	如果你确定当前session没有包含与之具有相同持久化标识的持久实例，使用<code class="literal">update()</code>。
        	如果想随时合并你的的改动而不考虑session的状态，使用<code class="literal">merge()</code>。
	         换句话说，在一个新session中通常第一个调用的是<code class="literal">update()</code>方法，以便保证重新关联脱管(detached)对象的操作首先被执行。
        </p>
<p>
		    如果希望相关联的脱管对象（通过引用“可到达”的脱管对象）的数据也要更新到数据库时（并且也<span class="emphasis"><em>仅仅</em></span>在这种情况），
		    可以对该相关联的脱管对象单独调用<code class="literal">update()</code>
			当然这些可以自动完成，即通过使用<span class="emphasis"><em>传播性持久化(transitive persistence)</em></span>，请看<a href="ch10s11.html" title="10.11.&#160;传播性持久化(transitive persistence)">第&#160;10.11&#160;节 “传播性持久化(transitive persistence)”</a>。
        </p>
<p>
            <code class="literal">lock()</code>方法也允许程序重新关联某个对象到一个新session上。不过，该脱管(detached)的对象必须是没有修改过的！
        </p>
<pre class="programlisting">//just reassociate:
sess.lock(fritz, LockMode.NONE);
//do a version check, then reassociate:
sess.lock(izi, LockMode.READ);
//do a version check, using SELECT ... FOR UPDATE, then reassociate:
sess.lock(pk, LockMode.UPGRADE);</pre>
<p>
            请注意，<code class="literal">lock()</code>可以搭配多种<code class="literal">LockMode</code>，
            更多信息请阅读API文档以及关于事务处理(transaction handling)的章节。重新关联不是<code class="literal">lock()</code>的唯一用途。
        </p>
<p>
            其他用于长时间工作单元的模型会在<a href="ch11s03.html" title="11.3.&#160;乐观并发控制(Optimistic concurrency control)">第&#160;11.3&#160;节 “乐观并发控制(Optimistic concurrency control)”</a>中讨论。
        </p>
</div></body>
</html>
