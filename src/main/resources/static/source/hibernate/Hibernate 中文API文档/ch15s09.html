<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>15.9.&#160;根据自然标识查询(Queries by natural identifier)</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="ch15.html" title="第&#160;15&#160;章&#160; 条件查询(Criteria Queries)">
<link rel="prev" href="ch15s08.html" title="15.8.&#160;离线(detached)查询和子查询">
<link rel="next" href="ch16.html" title="第&#160;16&#160;章&#160;Native SQL查询">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="query-criteria-naturalid"></a>15.9.&#160;根据自然标识查询(Queries by natural identifier)</h2></div></div></div>
<p>
            对大多数查询，包括条件查询而言，因为查询缓存的失效(invalidation)发生得太频繁，查询缓存不是非常高效。然而，有一种特别的查询，可以通过不变的自然键优化缓存的失效算法。在某些应用中，这种类型的查询比较常见。条件查询API对这种用例提供了特别规约。
        </p>
<p>
            首先，你应该对你的entity使用<code class="literal">&lt;natural-id&gt;</code>来映射自然键，然后打开第二级缓存。
        </p>
<pre class="programlisting">&lt;class name="User"&gt;
    &lt;cache usage="read-write"/&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;natural-id&gt;
        &lt;property name="name"/&gt;
        &lt;property name="org"/&gt;
    &lt;/natural-id&gt;
    &lt;property name="password"/&gt;
&lt;/class&gt;</pre>
<p>
            注意,此功能对具有<span class="emphasis"><em>mutable</em></span>自然键的entity并不适用。
        </p>
<p>
            然后，打开Hibernate 查询缓存。
        </p>
<p>
            现在，我们可以用<code class="literal">Restrictions.naturalId()</code>来使用更加高效的缓存算法。
        </p>
<pre class="programlisting">session.createCriteria(User.class)
    .add( Restrictions.naturalId()
        .set("name", "gavin")
        .set("org", "hb") 
    ).setCacheable(true)
    .uniqueResult();</pre>
</div></body>
</html>
