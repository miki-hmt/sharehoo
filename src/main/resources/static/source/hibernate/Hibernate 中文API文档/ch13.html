<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>第&#160;13&#160;章&#160;批量处理（Batch processing）</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="prev" href="ch12s03.html" title="12.3.&#160; Hibernate的声明式安全机制">
<link rel="next" href="ch13s02.html" title="13.2.&#160;批量更新（Batch updates）">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title">
<a name="batch"></a>第&#160;13&#160;章&#160;批量处理（Batch processing）</h2></div></div></div>
<div class="toc">
<p><b>目录</b></p>
<dl>
<dt><span class="sect1"><a href="ch13.html#batch-inserts">13.1. 批量插入（Batch inserts）</a></span></dt>
<dt><span class="sect1"><a href="ch13s02.html">13.2. 批量更新（Batch updates）</a></span></dt>
<dt><span class="sect1"><a href="ch13s03.html">13.3. StatelessSession (无状态session)接口</a></span></dt>
<dt><span class="sect1"><a href="ch13s04.html">13.4. DML(数据操作语言)风格的操作(DML-style operations)</a></span></dt>
</dl>
</div>
<p>
        使用Hibernate将 100 000 条记录插入到数据库的一个很自然的做法可能是这样的
    </p>
<pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
for ( int i=0; i&lt;100000; i++ ) {
    Customer customer = new Customer(.....);
    session.save(customer);
}
tx.commit();
session.close();</pre>
<p>
        这段程序大概运行到 50 000 条记录左右会失败并抛出 <code class="literal">内存溢出异常（OutOfMemoryException）</code> 。
        这是因为 Hibernate 把所有新插入的 <code class="literal">客户（Customer）</code>实例在 session级别的缓存区进行了缓存的缘故。
    </p>
<p>
        我们会在本章告诉你如何避免此类问题。首先，如果你要执行批量处理并且想要达到一个理想的性能，
        那么使用JDBC的批量（batching）功能是至关重要。将JDBC的批量抓取数量（batch size）参数设置到一个合适值
        （比如，10-50之间）：
    </p>
<pre class="programlisting">hibernate.jdbc.batch_size 20</pre>
<p><a name="disablebatching"></a>
        注意,假若你使用了<code class="literal">identiy</code>标识符生成器,Hibernate在JDBC级别透明的关闭插入语句的批量执行。
    </p>
<p>
        你也可能想在执行批量处理时关闭二级缓存：
    </p>
<pre class="programlisting">hibernate.cache.use_second_level_cache false</pre>
<p>
        但是，这不是绝对必须的，因为我们可以显式设置<code class="literal">CacheMode</code>来关闭与二级缓存的交互。
    </p>
<div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="batch-inserts"></a>13.1.&#160;批量插入（Batch inserts）</h2></div></div></div>
<p>
            如果要将很多对象持久化，你必须通过经常的调用 <code class="literal">flush()</code> 以及稍后调用 
            <code class="literal">clear()</code> 来控制第一级缓存的大小。
        </p>
<pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
   
for ( int i=0; i&lt;100000; i++ ) {
    Customer customer = new Customer(.....);
    session.save(customer);
    if ( i % 20 == 0 ) { //20, same as the JDBC batch size //20,与JDBC批量设置相同
        //flush a batch of inserts and release memory:
        //将本批插入的对象立即写入数据库并释放内存
        session.flush();
        session.clear();
    }
}
   
tx.commit();
session.close();</pre>
</div>
</div></body>
</html>
