<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>第&#160;12&#160;章&#160; 拦截器与事件(Interceptors and events)</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="up" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化">
<link rel="prev" href="ch11s05.html" title="11.5.&#160;连接释放模式(Connection Release Modes)">
<link rel="next" href="ch12s02.html" title="12.2.&#160; 事件系统(Event system)">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title">
<a name="events"></a>第&#160;12&#160;章&#160;
	拦截器与事件(Interceptors and events)
	</h2></div></div></div>
<div class="toc">
<p><b>目录</b></p>
<dl>
<dt><span class="sect1"><a href="ch12.html#objectstate-interceptors">12.1. 
		拦截器(Interceptors)
		</a></span></dt>
<dt><span class="sect1"><a href="ch12s02.html">12.2. 
		事件系统(Event system)
		</a></span></dt>
<dt><span class="sect1"><a href="ch12s03.html">12.3. 
		Hibernate的声明式安全机制
		</a></span></dt>
</dl>
</div>
<p>
	    应用程序能够响应Hibernate内部产生的特定事件是非常有用的。这样就允许实现某些通用的功能
		以及允许对Hibernate功能进行扩展。
    </p>
<div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="objectstate-interceptors"></a>12.1.&#160;
		拦截器(Interceptors)
		</h2></div></div></div>
<p>
            <code class="literal">Interceptor</code>接口提供了从会话(session)回调(callback)应用程序(application)的机制，
                        这种回调机制可以允许应用程序在持久化对象被保存、更新、删除或是加载之前，检查并（或）修改其
			属性。一个可能的用途，就是用来跟踪审核(auditing)信息。例如：下面的这个<code class="literal">拦截器</code>，会在一个实现了
			<code class="literal">Auditable</code>接口的对象被创建时自动地设置<code class="literal">createTimestamp</code>属性，并在实现了
			<code class="literal">Auditable</code>接口的对象被更新时，同步更新<code class="literal">lastUpdateTimestamp</code>属性。
        </p>
<p>
            你可以直接实现<code class="literal">Interceptor</code>接口，也可以（最好）继承自<code class="literal">EmptyInterceptor</code>。
        </p>
<pre class="programlisting">package org.hibernate.test;

import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;

import org.hibernate.EmptyInterceptor;
import org.hibernate.Transaction;
import org.hibernate.type.Type;

public class AuditInterceptor extends EmptyInterceptor {

    private int updates;
    private int creates;
    private int loads;

    public void onDelete(Object entity,
                         Serializable id,
                         Object[] state,
                         String[] propertyNames,
                         Type[] types) {
        // do nothing
    }

    public boolean onFlushDirty(Object entity,
                                Serializable id,
                                Object[] currentState,
                                Object[] previousState,
                                String[] propertyNames,
                                Type[] types) {

        if ( entity instanceof Auditable ) {
            updates++;
            for ( int i=0; i &lt; propertyNames.length; i++ ) {
                if ( "lastUpdateTimestamp".equals( propertyNames[i] ) ) {
                    currentState[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public boolean onLoad(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {
        if ( entity instanceof Auditable ) {
            loads++;
        }
        return false;
    }

    public boolean onSave(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {

        if ( entity instanceof Auditable ) {
            creates++;
            for ( int i=0; i&lt;propertyNames.length; i++ ) {
                if ( "createTimestamp".equals( propertyNames[i] ) ) {
                    state[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public void afterTransactionCompletion(Transaction tx) {
        if ( tx.wasCommitted() ) {
            System.out.println("Creations: " + creates + ", Updates: " + updates, "Loads: " + loads);
        }
        updates=0;
        creates=0;
        loads=0;
    }

}</pre>
<p>
            拦截器可以有两种:<code class="literal">Session</code>范围内的，和<code class="literal">SessionFactory</code>范围内的。
        </p>
<p>
		    当使用某个重载的SessionFactory.openSession()使用<code class="literal">Interceptor</code>作为参数调用打开一个session的时候，就指定了<code class="literal">Session</code>范围内的拦截器。
		    
        </p>
<pre class="programlisting">Session session = sf.openSession( new AuditInterceptor() );</pre>
<p>
		    <code class="literal">SessionFactory</code>范围内的拦截器要通过<code class="literal">Configuration</code>中注册，而这必须在创建<code class="literal">SessionFactory</code>之前。在这种情况下，给出的拦截器会被这个<code class="literal">SessionFactory</code>所打开的所有session使用了；除非session打开时明确指明了使用的拦截器。<code class="literal">SessionFactory</code>范围内的拦截器，必须是线程安全的，因为多个session可能并发使用这个拦截器，要因此小心不要保存与session相关的状态。
        </p>
<pre class="programlisting">new Configuration().setInterceptor( new AuditInterceptor() );</pre>
</div>
</div></body>
</html>
