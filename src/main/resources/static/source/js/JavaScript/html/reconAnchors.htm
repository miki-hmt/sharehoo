<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=gb2312">
<TITLE>定位符</TITLE>
<!--CSS_START-->
<style>@import url(../html-vss/msdnie4a.css);</style>
<link disabled rel="stylesheet" href="../html-vss/msdn_ie3.css">
<!--CSS_END-->
</HEAD>
<BODY>


<!--Start Head-->
<TABLE class="banner" width="100%" CELLSPACING=0>
<TR>
<TD class="bannerleft" nowrap>JScript&nbsp;</TD>
<TD class="bannerright" nowrap><a href="../html-vss/jsTOC.htm">语言参考</a></TD>
</TR>
</TABLE>
<HR>
<!--End Head-->

<H2><A NAME="reconanchors"></A>定位符</H2>

<P>到现在为止，所看到的示例都只考虑查找任何地方出现的章节标题。出现的任何一个字符串 'Chapter' 后跟一个空格和一个数字可能是一个真正的章节标题，也可能是对其他章节的交叉引用。由于真正的章节标题总是出现在一行的开始，因此需要设计一个方法只查找标题而不查找交叉引用。</P>

<P>定位符提供了这个功能。定位符可以将一个正则表达式固定在一行的开始或结束。也可以创建只在单词内或只在单词的开始或结尾处出现的正则表达式。下表包含了正则表达式及其含义的列表：</P>

<TABLE border=1 cellspacing=0 cols=2 frame=box rules=all>

<TR VALIGN="top">
<TH width=16%>字符</TH>
<TH width=84%>描述</TH>
</TR>

<TR VALIGN="top">
<TD width=16%>^</TD>
<TD width=84%>匹配输入字符串的开始位置。如果设置了 <B>RegExp</B> 对象的 <B>Multiline</B> 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。</TD>
</TR>

<TR VALIGN="top">
<TD width=16%>$</TD>
<TD width=84%>匹配输入字符串的结束位置。如果设置了<B>RegExp</B> 对象的 <B>Multiline</B> 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。</TD>
</TR>

<TR VALIGN="top">
<TD width=16%>\b</TD>
<TD width=84%>匹配一个单词边界，也就是指单词和空格间的位置。</TD>
</TR>

<TR VALIGN="top">
<TD width=16%>\B</TD>
<TD width=84%>匹配非单词边界。</TD>
</TR>
</TABLE><BR>

<P>不能对定位符使用限定符。因为在一个换行符或者单词边界的前面或后面不会有连续多个位置，因此诸如 '^*' 的表达式是不允许的。</P>

<P>要匹配一行文字开始位置的文字，请在正则表达式的开始处使用 '^' 字符。不要把 '^' 的这个语法与其在括号表达式中的语法弄混。它们的语法根本不同。 </P>

<P>要匹配一行文字结束位置的文字，请在正则表达式的结束处使用 '$' 字符。</P>

<P>要在查找章节标题时使用定位符，下面的 JScript 正则表达式将匹配位于一行的开始处最多有两个数字的章节标题：</P>

<PRE><CODE>/^Chapter [1-9][0-9]{0,1}/</CODE></PRE>

<P>VBScript 中相同功能的正则表达式如下：</P>

<PRE><CODE>"^Chapter [1-9][0-9]{0,1}"</CODE></PRE>

<P>一个真正的章节标题不仅出现在一行的开始，而且这一行中也仅有这一个内容，因此，它必然也位于一行的结束。下面的表达式确保所指定的匹配只匹配章节而不会匹配交叉引用。它是通过创建一个只匹配一行文字的开始和结束位置的正则表达式来实现的。</P>

<PRE><CODE>/^Chapter [1-9][0-9]{0,1}$/</CODE></PRE>

<P>对 VBScript 则使用：</P>

<PRE><CODE>"^Chapter [1-9][0-9]{0,1}$"</CODE></PRE>

<P>匹配单词边界有少许不同，但却给正则表达式增加了一个非常重要的功能。单词边界就是单词和空格之间的位置。非单词边界就是其他任何位置。下面的 JScript 表达式将匹配单词 'Chapter' 的前三个字符，因为它们出现在单词边界后：</P>

<PRE><CODE>/\bCha/</CODE></PRE>

<P>对 VBScript 为：</P>

<PRE><CODE>"\bCha"</CODE></PRE>

<P>这里 '\b' 操作符的位置很关键。如果它位于要匹配的字符串的开始，则将查找位于单词开头处的匹配；如果它位于改字符串的末尾，则查找位于单词结束处的匹配。例如，下面的表达式将匹配单词 'Chapter' 中的 'ter'，因为它出现在单词边界之前：</P>

<PRE><CODE>/ter\b/</CODE></PRE>

<P>以及</P>

<PRE><CODE>"ter\b"</CODE></PRE>

<P>下面的表达式将匹配 'apt'，因为它位于 'Chapter' 中间，但不会匹配 'aptitude' 中的'apt'：</P>

<PRE><CODE>/\Bapt/</CODE></PRE>

<P>以及</P>

<PRE><CODE>"\Bapt"</CODE></PRE>

<P>这是因为在单词 'Chapter' 中 'apt' 出现在非单词边界位置，而在单词 'aptitude' 中位于单词边界位置。非单词边界操作符的位置不重要，因为匹配与一个单词的开头或结尾无关。</P>
<!--Copyright_START-->
<DIV CLASS="footer">
<HR><a href="jscopy.htm">&copy; 2000 Microsoft Corporation 版权所有。保留所有权利。使用规定。</a><br>
</DIV> <!--Copyright_END-->

</BODY>
</HTML>
