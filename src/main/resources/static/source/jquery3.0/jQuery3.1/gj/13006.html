<!DOCTYPE html>
<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, minimumscale=1.0, maximum-scale=1.0" />
<meta name="language" content="zh-cn" />
<meta name="renderer" content="webkit" />
<title>jQuery.when()</title>
<link rel="stylesheet" type="text/css" href="../style/prettify.css" />
<link rel="stylesheet" type="text/css" href="../style/bootstrap.min.css" />
<link rel="stylesheet" type="text/css" href="../style/love.css" />
<script type="text/javascript" src="../style/jquery.min.js"></script>
<script type="text/javascript" src="../style/bootstrap.min.js"></script>
<script type="text/javascript" src="../style/prettify.js"></script>
</head>
<body>
<div id="post-content" class="m-bg">
	<h1 class="text-center">jQuery.when()</h1>
	<hr>
		<h3>
	<blockquote>
		概述&nbsp;&nbsp;&nbsp;&nbsp;jQuery.when( deferreds )
	</blockquote>
</h3>
<div class="desc">
	<p>
		返回值：<a href="http://www.shouce.ren/api/view/a/13081#articleHeader42" target="_blank">Promise</a> 
	</p>
</div>
<p>
</p>
<p class="desc">
	<strong>描述：</strong>提供一种方法来执行零个或多个对象的回调函数， Deferred(延迟)对象通常表示异步事件。
</p>
<ul class="signatures">
	<li class="signature" id="jQuery-when-deferreds">
		<h4 class="name">
			<span class="version-details">V : 1.5</span>jQuery.when( deferreds )
		</h4>
		<ul>
			<li>
				<div>
					<strong>deferreds</strong> 
				</div>
				<div>
					类型: Deferred
				</div>
				<div>
					零个或多个延迟对象，或者普通的JavaScript对象。
				</div>
			</li>
		</ul>
	</li>
</ul>
<div class="longdesc" id="entry-longdesc">
	<p>
		如果没有参数传递给 <code>jQuery.when()</code>，它会返回一个resolved状态的Promise。
	</p>
	<p>
		如果向 <code>jQuery.when()</code> 传入一个单独的延迟对象，那么会返回它的 Promise 对象(延迟方法的一个子集)。可以继续绑定 Promise 对象的其它方法，例如， <code>defered.then</code> 。当延迟对象已经被解决（resolved）或被拒绝(rejected）（通常是由创建延迟对象的最初代码执行的），那么就会调用适当的回调函数。例如，由 <code>jQuery.ajax()</code> 返回的 jqXHR 对象是一并立的延迟对象并且可以像下面这样使用：
	</p>
	<div class="syntaxhighlighter javascript nogutter">
<pre class="prettyprint lang-js">$.when( $.ajax("test.aspx") ).then(function(data, textStatus, jqXHR){
     alert( jqXHR.status ); // alerts 200
});</pre>
	</div>
	<p>
		如果一个参数被传递给<code>jQuery.when()</code> ， 并且它不是一个Deferred或Promise对象，
      那么它会被当作是一个被解决（resolved）的延迟对象，并且绑定到上面的任何 doneCallbacks 都会被立刻执行。向 
doneCallbacks 中传入的是原始的参数。在这种情况下，设定的任何 failCallbacks 
永远都不会被执行，因为延迟对象永远不会被拒绝（rejected）。例如：
	</p>
	<div class="syntaxhighlighter javascript nogutter">
<pre class="prettyprint lang-js">$.when( { testing: 123 } ).done(
    function(x) { alert(x.testing); } /* alerts "123" */
    );</pre>
	</div>
	<p>
		如果你不传递任何参数，
    &nbsp;<code>jQuery.when()</code>将返回一个resolved（解决）状态的promise对象。
	</p>
	<div class="syntaxhighlighter javascript nogutter">
<pre class="prettyprint lang-js">$.when().then(function( x ) {
  alert( "I fired immediately" );
});</pre>
	</div>
	<p>
		在多个延迟对象传递给<code>jQuery.when()</code> 的情况下，该方法根据一个新的“宿主” 
Deferred（延迟）对象，跟踪所有已通过Deferreds聚集状态，返回一个Promise对象。当所有的延迟对象被解决（resolve）时，“宿主”
 Deferred（延迟）对象才会解决（resolved）该方法，或者当其中有一个延迟对象被拒绝（rejected）时，“宿主” 
Deferred（延迟）对象就会reject（拒绝）该方法。如果“宿主” Deferred（延迟）对象是（resolved）解决状态时， 
“宿主” Deferred（延迟）对象的 doneCallbacks （解决回调）将被执行。参数传递给 
doneCallbacks提供这解决（resolved）值给每个对应的Deferreds对象，并匹配Deferreds传递给 <code>jQuery.when()</code>的顺序。
        例如：
	</p>
	<div class="syntaxhighlighter javascript nogutter">
<pre class="prettyprint lang-js">var d1 = $.Deferred();
var d2 = $.Deferred();
 
$.when( d1, d2 ).done(function ( v1, v2 ) {
    console.log( v1 ); // "Fish"
    console.log( v2 ); // "Pizza"
});
 
d1.resolve( "Fish" );
d2.resolve( "Pizza" );</pre>
	</div>
	<p>
		如果没有值传递给 Deferred递延对象的解决（resolved）事件，
        那么相应的doneCallback参数将是<code>undefined</code>。
        如果传递给Deferred递延对象的解决（resolved）事件为单个的值，
        相应的参数将保留那个值。
        在传递给Deferred递延对象的解决（resolved）事件为为多个值的情况下，
        相应的参数将是这些值组成的数组。例如：
	</p>
	<div class="syntaxhighlighter javascript nogutter">
<pre class="prettyprint lang-js">var d1 = $.Deferred();
var d2 = $.Deferred();
var d3 = $.Deferred();
 
$.when( d1, d2, d3 ).done(function ( v1, v2, v3 ) {
    console.log( v1 ); // v1 is undefined
    console.log( v2 ); // v2 is "abc"
    console.log( v3 ); // v3 is an array [ 1, 2, 3, 4, 5 ]
});
 
d1.resolve();
d2.resolve( "abc" );
d3.resolve( 1, 2, 3, 4, 5 );</pre>
	</div>
	<p>
		在多延迟情况下，如果Deferreds延迟对象一被拒绝（rejected），<code>jQuery.when()</code>触发立即调用
  “宿主” Deferred（延迟）对象的 
failCallbacks。请注意在这个时间点上，有一些延迟对象仍然可以是未解决（unresolved）的。  
传递给failCallbacks的参数匹配Deferred（延迟）对象的 failCallbacks被 rejected 
拒绝的顺序。那么，在这种情况下，如果需要执行一些额外的处理，例如，取消所有未完成的 ajax 请求，你可以在闭包中进行保持 jqXHR 
对象的引用，并且在 failCallback 中检查或取消它们。
	</p>
</div>
<div class="jquery-api-top">
</div>
<header>
<h3 class="underline">
	<blockquote>
		示例
	</blockquote>
</h3>
</header>
<div class="entry-example" id="example-0">
	<h4>
		实例
	</h4>
	<p>
		<span class="desc">执行Ajax请求后两个函数是成功的。（见jQuery.ajax()对于一个成功的和错误的案件为AJAX请求的完整描述文档）。</span> 
	</p>
	<div class="syntaxhighlighter javascript ">
<pre class="prettyprint lang-js">$.when($.ajax("/page1.php"), $.ajax("/page2.php")).done(function(a1,  a2){
  /* a1 and a2 are arguments resolved for the
      page1 and page2 ajax requests, respectively */
  var jqXHR = a1[2]; /* arguments are [ "success", statusText, jqXHR ] */
  if ( /Whip It/.test(jqXHR.responseText) ) {
    alert("First page has 'Whip It' somewhere.");
  }
});</pre>
	</div>
</div>
<h4>
	实例
</h4>
<p>
	<span class="desc">执行函数<code>myFunc</code>当两个Ajax请求是成功的，如果任一或<code>myFailure</code>有一个错误。 </span> 
</p>
<pre class="prettyprint lang-js">$.when($.ajax("/page1.php"), $.ajax("/page2.php"))
  .then(myFunc, myFailure);</pre>
<p>
</p></div>
<div class="m-bg text-center margin_t_1">
	<a class="btn btn-sm btn-default" href="http://www.shouce.ren"><strong>手册网</strong></a>
</div>
<script type="text/javascript">
$(function(){
	$("pre").addClass("prettyprint linenums");
	//代码高亮
	prettyPrint();
	$("table").attr('class','table table-striped table-bordered table-condensed');
});
</script>
</body>
</html>
