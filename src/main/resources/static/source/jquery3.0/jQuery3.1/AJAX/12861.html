<!DOCTYPE html>
<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, minimumscale=1.0, maximum-scale=1.0" />
<meta name="language" content="zh-cn" />
<meta name="renderer" content="webkit" />
<title>jQuery.ajax()</title>
<link rel="stylesheet" type="text/css" href="../style/prettify.css" />
<link rel="stylesheet" type="text/css" href="../style/bootstrap.min.css" />
<link rel="stylesheet" type="text/css" href="../style/love.css" />
<script type="text/javascript" src="../style/jquery.min.js"></script>
<script type="text/javascript" src="../style/bootstrap.min.js"></script>
<script type="text/javascript" src="../style/prettify.js"></script>
</head>
<body>
<div id="post-content" class="m-bg">
	<h1 class="text-center">jQuery.ajax()</h1>
	<hr>
		<h3>
	<blockquote>
		概述&nbsp;&nbsp;&nbsp;&nbsp;jQuery.ajax( url [, settings ] )
	</blockquote>
</h3>
<p>
	返回值：<a href="http://www.shouce.ren/api/view/a/13081#articleHeader40" target="_blank">XMLHttpRequest</a> 
</p>
<p>
</p>
<p class="desc">
	<strong>说明: </strong>执行一个异步的HTTP（Ajax）的请求。
</p>
<ul class="signatures">
	<li class="signature" id="jQuery-ajax-url-settings">
		<h4 class="name">
			<span class="version-details">V : 1.5</span>jQuery.ajax( url [, settings ] )
		</h4>
		<ul>
			<li>
				<div>
					<strong>url</strong> 
				</div>
				<div>
					类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader0">String</a> 
				</div>
				<div>
					一个用来包含发送请求的URL字符串。
				</div>
			</li>
			<li>
				<div>
					<strong>settings</strong> 
				</div>
				<div>
					类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader25">PlainObject</a> 
				</div>
				<div>
					一个以"{键:值}"组成的AJAX 请求设置。所有选项都是可选的。可以使用<a href="http://www.shouce.ren/api/view/a/12874" class="book-a">$.ajaxSetup()</a>设置任何默认参数。看<code>jQuery.ajax( settings )</code>下所有设置的完整列表。
				</div>
			</li>
		</ul>
	</li>
	<li class="signature" id="jQuery-ajax-settings">
		<h4 class="name">
			<span class="version-details">V : 1.0</span>jQuery.ajax(  [settings ] )
		</h4>
		<ul>
			<li>
				<div>
					<strong>settings</strong> 
				</div>
				<div>
					类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader25">PlainObject</a> 
				</div>
				<div>
					一个以"{键:值}"组成的AJAX 请求设置。所有选项都是可选的。可以使用<a href="http://www.shouce.ren/api/view/a/12874" class="book-a">$.ajaxSetup()</a>设置任何默认参数。
				</div>
				<ul>
					<li>
						<div>
							<strong>accepts</strong> (默认: <code>取决于数据类型</code>)
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader25">PlainObject</a> 
						</div>
						<div>
							一个键/值对集合映射给定的<code>dataType</code> 到其的MIME类型，它可以从发送<code>Accept</code>请求头信息中获得。
                            请求头信息通知服务器该请求需要接收何种类型的返回结果。
                            例如，下面定义一个自定义类型的<code>mycustomtype</code>与请求一起发送：
							<div class="syntaxhighlighter javascript">
<pre class="prettyprint lang-js">$.ajax({
  accepts: {
    mycustomtype: 'application/x-some-custom-type'
  },
 
  // Instructions for how to deserialize a `mycustomtype`
  converters: {
    'text mycustomtype': function(result) {
      // Do Stuff
      return newresult;
    }
  },
 
  // Expect a `mycustomtype` back from server
  dataType: 'mycustomtype'
});</pre>
							</div>
<strong>注意:</strong> 对于这种类型，为了使其正常工作，您将需要在<code>converters</code>中指定补充项。
						</div>
					</li>
					<li>
						<div>
							<strong>async</strong> (默认: <code>true</code>)
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader14">Boolean</a> 
						</div>
						<div>
							默认设置下，所有请求均为异步请求（也就是说这是默认设置为 <code>true</code> ）。如果需要发送同步请求，请将此选项设置为 <code>false</code> 。跨域请求和 <code>dataType: "jsonp"</code> 请求不支持同步操作。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。<strong>从 jQuery 1.8 开始</strong>, jqXHR (<code>$.Deferred</code>)中使用 <code> async: false </code> 已经过时。您必须使用的 success/error/complete 的回调选项代替相应的jqXHR对象的方法，比如<code>jqXHR.done()</code> <del>或者过时的<code>jqXHR.success()</code></del>。
						</div>
					</li>
					<li>
						<div>
							<strong>beforeSend</strong> 
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader28">Function</a>( jqXHR jqXHR, <a href="http://www.shouce.ren/api/view/a/13081#articleHeader25">PlainObject</a> settings )
						</div>
						<div>
							请求发送前的回调函数，用来修改请求发送前jqXHR（在jQuery 1.4.x的中，XMLHttpRequest）对象，此功能用来设置自定义 HTTP 头信息，等等。该jqXHR和设置对象作为参数传递。这是一个<a href="http://docs.jquery.com/Ajax_Events">Ajax事件</a> 。在<code>beforeSend</code>函数中返回<code>false</code>将取消这个请求。<strong>从jQuery 1.5开始，</strong> <code>beforeSend</code>选项将被访问，不管请求的类型。
						</div>
					</li>
					<li>
						<div>
							<strong>cache</strong> (默认: <code>true, dataType为"script"和"jsonp"时默认为false</code>)
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader14">Boolean</a> 
						</div>
						<div>
							如果设置为 false ，浏览器将不缓存此页面。<strong>注意:</strong> 设置<code>cache</code>为 false将在 HEAD和GET请求中正常工作。它的工作原理是在GET请求参数中附加"_={timestamp}"（译者注：时间戳）。该参数不是其他请求所必须的，除了在IE8中，当一个POST请求一个已经用GET请求过的URL。
						</div>
					</li>
					<li>
						<div>
							<strong>complete</strong> 
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader28">Function</a>( jqXHR jqXHR, String textStatus )
						</div>
						<div>
							请求完成后回调函数 (请求<code>success</code> 和 <code>error</code>之后均调用)。这个回调函数得到2个参数： jqXHR (在 jQuery 1.4.x中是 XMLHTTPRequest) 对象和一个描述请求状态的字符串(<code>"success"</code>, <code>"notmodified"</code>, <code>"nocontent"</code>，<code>"error"</code>, <code>"timeout"</code>, <code>"abort"</code>, 或者 <code>"parsererror"</code>) 。<strong>从jQuery 1.5开始，</strong> <code>complete</code>设置可以接受一个函数的数组。每个函数将被依次调用。这是一个<a href="http://docs.jquery.com/Ajax_Events">Ajax事件</a> 。
						</div>
					</li>
					<li>
						<div>
							<strong>contents</strong> 
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader25">PlainObject</a> 
						</div>
						<div>
							一个以"{字符串/正则表达式}"配对的对象，根据给定的内容类型，解析请求的返回结果。<span class="version-details"> (1.5新增)</span> 
						</div>
					</li>
					<li>
						<div>
							<strong>contentType</strong> (default: <code>'application/x-www-form-urlencoded; charset=UTF-8'</code>)
						</div>
						<div>
							Type: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader14">Boolean</a> or <a href="http://www.shouce.ren/api/view/a/13081#articleHeader0">String</a> 
						</div>
						<div>
							当将数据发送到服务器时，使用该内容类型。默认值是"application/x-www-form-urlencoded; 
charset=UTF-8"，适合大多数情况。如果你明确地传递了一个内容类型（Content-Type）给 <code>$.ajax()</code>，那么他总是会发送给服务器（即使没有数据要发送）。从 jQuery 1.6 开始，你可以传递<code>false</code>来告诉jQuery，没有设置任何内容类型头信息。 <strong>注意：</strong>W3C的XMLHttpRequest的规范规定，数据将总是使用UTF-8字符集传递给服务器；指定其他字符集无法强制浏览器更改编码。 <strong>注意:</strong>对于跨域请求，内容类型设置为<code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, 或 <code>text/plain</code>以外， 将触发浏览器发送一个预检OPTIONS请求到服务器。
						</div>
					</li>
					<li>
						<div>
							<strong>context</strong> 
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader15">Object</a> 
						</div>
						<div>
							这个对象用于设置Ajax相关回调函数的上下文。
                        默认情况下，这个上下文是一个ajax请求使用的参数设置对象，（<code>$.ajaxSettings</code>合并独傲这个设置，传递给<code>$.ajax</code>）。比如指定一个DOM元素作为context参数，这样就设置了<code>complete</code>回调函数的上下文为这个DOM元素。就像这样：
							<div class="syntaxhighlighter javascript nogutter">
<pre class="prettyprint lang-js">$.ajax({
  url: "test.html",
  context: document.body
}).done(function() {
  $(this).addClass("done");
});</pre>
							</div>
						</div>
					</li>
					<li>
						<div>
							<strong>converters</strong> (默认: <code>{"* text": window.String, "text html": true, "text json": jQuery.parseJSON, "text xml": jQuery.parseXML}</code>)
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader25">PlainObject</a> 
						</div>
						<div>
							一个数据类型到数据类型转换器的对象。每个转换器的值是一个函数，返回经转换后的请求结果。 <span class="version-details"> ( 1.5新增)</span> 
						</div>
					</li>
					<li>
						<div>
							<strong>crossDomain</strong> (默认: <code>同域请求为false， 跨域请求为true</code>)
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader14">Boolean</a> 
						</div>
						<div>
							如果你想在同一域中强制跨域请求（如JSONP形式），例如，想服务器端重定向到另一个域，那么需要将crossDomain设置为 <code>true</code> 。<span class="version-details"> ( 1.5 新增)</span> 
						</div>
					</li>
					<li>
						<div>
							<strong>data</strong> 
						</div>
						<div>
							类型: PlainObject 或 <a href="http://www.shouce.ren/api/view/a/13081#articleHeader0">String</a> 或 <a href="http://www.shouce.ren/api/view/a/13081#articleHeader21">Array</a> 
						</div>
						<div>
							发送到服务器的数据。它被转换成一个查询字符串,如果已经是一个字符串的话就不会转换。查询字符串将被追加到GET请求的URL后面。参见 <code>processData</code> 选项说明，以防止这种自动转换。对象必须为"{键:值}"格式。如果这个参数是一个数组，jQuery会按照<code>traditional</code> 参数的值， 将自动转化为一个同名的多值查询字符串(查看下面的说明)。手册网注：如 {foo:["bar1", "bar2"]} 转换为 '&amp;foo=bar1&amp;foo=bar2'。
						</div>
					</li>
					<li>
						<div>
							<strong>dataFilter</strong> 
						</div>
						<div>
							类型: Function( <a href="http://www.shouce.ren/api/view/a/13081#articleHeader0">String</a> data, <a href="http://www.shouce.ren/api/view/a/13081#articleHeader0">String</a> type )
                        			=&gt; Anything
						</div>
						<div>
							一个函数被用来处理XMLHttpRequest的原始响应数据。这是一个预过滤功能，净化响应。您应该返回安全数据。提供data和type两个参数：data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。
						</div>
					</li>
					<li>
						<div>
							<strong>dataType</strong> (default: <code>Intelligent Guess (xml, json, script, or html)</code>)
						</div>
						<div>
							Type: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader0">String</a> 
						</div>
						<div>
							从服务器返回你期望的数据类型。
                      如果没有指定，jQuery将尝试通过MIME类型的响应信息来智能判断（一个XML 
MIME类型就被识别为XML，在1.4中 JSON将生成一个JavaScript对象，在1.4中 script 
将执行该脚本，其他任何类型会返回一个字符串）。&nbsp;可用的类型（以及结果作为第一个参数传递给成功回调函数）有：
							<ul>
								<li>
									<code>"xml"</code>: 返回 XML 文档，可以通过 jQuery 处理。
								</li>
								<li>
									<code>"html"</code>: 返回纯文本 HTML 文本；包含的script标签会在插入DOM时执行。
								</li>
								<li>
									<code>"script"</code>: 把响应的结果当作 JavaScript 执行，并将其当作纯文本返回。默认情况下会通过在URL中附加查询字符串变量 ，<code>_=[TIMESTAMP]</code>， 禁用缓存结果，除非设置了<code>cache</code>参数为<code>true</code>。<strong>注意:</strong> 在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。(手册网注：因为将使用DOM的script标签来加载)
								</li>
								<li>
									<code>"json"</code>:把响应的结果当作 JSON 执行，并返回一个JavaScript对象。跨域<code>"json"</code> 请求转换为<code>"jsonp"</code>，除非该请求在其请求选项中设置了<code>jsonp:false</code>。JSON 数据以严格的方式解析; 任何畸形的JSON将被拒绝，并且抛出解析错误信息。在jQuery1.9中，一个空响应也将被拒绝;服务器应该返回<code>null</code>或 <code>{}</code>响应代替。（见<a href="http://json.org/">json.org</a>的更多信息，正确的JSON格式。）
								</li>
								<li>
									<code>"jsonp"</code>: 以 <a href="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/">JSONP</a> 的方式载入 JSON 数据块。会自动在所请求的URL最后添加<code>"?callback=?"</code>。默认情况下会通过在URL中附加查询字符串变量 ，<code>_=[TIMESTAMP]</code>， 禁用缓存结果，除非设置了<code>cache</code>参数为<code>true</code>。
								</li>
								<li>
									<code>"text"</code>: 返回纯文本字符串。
								</li>
								<li>
									多个用空格分割的值:<strong>从 jQuery 1.5 开始</strong>，  jQuery可以内容类型（Content-Type）头收到并转换一个您需要的数据类型。例如，如果你想要一个文本响应为XML处理，使用<code>"text xml"</code>数据类型。您也可以将一个JSONP的请求，以文本形式接受，并用jQuery以XML解析: <code>"jsonp text xml"</code>。同样地可以使用"jsonp xml"简写,首先会尝试从 jsonp 到 xml 的转换，如果转换失败，就先将 jsonp 转换成 text, 然后再由 text 转换成 xml。
								</li>
							</ul>
						</div>
					</li>
					<li>
						<div>
							<strong>error</strong> 
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader28">Function</a>( jqXHR jqXHR, <a href="http://www.shouce.ren/api/view/a/13081#articleHeader0">String</a> textStatus, <a href="http://www.shouce.ren/api/view/a/13081#articleHeader0">String</a> errorThrown )
						</div>
						<div>
							请求失败时调用此函数。有以下三个参数：jqXHR (在 jQuery 1.4.x前为XMLHttpRequest) 对象、描述发生错误类型的一个字符串 和 捕获的异常对象。如果发生了错误，错误信息（第二个参数）除了得到<code>null</code>之外，还可能是<code>"timeout"</code>, <code>"error"</code>, <code>"abort"</code> ，和 <code>"parsererror"</code>。
                      当一个HTTP错误发生时，<code>errorThrown</code> 接收HTTP状态的文本部分，比如： "Not Found"（没有找到） 或者 "Internal Server Error."（服务器内部错误）。 <strong>从jQuery 1.5开始</strong>, 在<code>error</code>设置可以接受函数组成的数组。每个函数将被依次调用。 <strong>注意：</strong><em>此处理程序在跨域脚本和JSONP形式的请求时不被调用。</em>这是一个 <a href="http://docs.jquery.com/Ajax_Events">Ajax Event</a>。
						</div>
					</li>
					<li>
						<div>
							<strong>global</strong> (默认: <code>true</code>)
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader14">Boolean</a> 
						</div>
						<div>
							无论怎么样这个请求将触发全局AJAX事件处理程序。默认是<code>true</code> 。设置为 <code>false</code> 将不会触发全局 AJAX 事件，如 <code>ajaxStart</code> 或者 <code>ajaxStop</code>。这可以用来控制各种 <a href="http://docs.jquery.com/Ajax_Events">Ajax Event</a>.
						</div>
					</li>
					<li>
						<div>
							<strong>headers</strong> (默认: <code>{}</code>)
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader25">PlainObject</a> 
						</div>
						<div>
							一个额外的"{键:值}"对映射到请求一起发送。此设置会在<code>beforeSend</code> 函数调用之前被设置 ;因此，请求头中的设置值，会被<code>beforeSend</code> 函数内的设置覆盖 。 <span class="version-details"> (1.5 新增 ）</span> 
						</div>
					</li>
					<li>
						<div>
							<strong>ifModified</strong> (默认: <code>false</code>)
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader14">Boolean</a> 
						</div>
						<div>
							只有上次请求响应改变时，才允许请求成功。使用 HTTP 包 Last-Modified 头信息判断。默认值是<code>false</code>，忽略HTTP头信息。在jQuery 1.4中，他也会检查服务器指定的'etag'来确定数据没有被修改过。
						</div>
					</li>
					<li>
						<div>
							<strong>isLocal</strong> (默认: <code>取决于当前的位置协议</code>)
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader14">Boolean</a> 
						</div>
						<div>
							允许当前环境被认定为“本地”，（如文件系统），即使jQuery默认情况下不会这么做。以下协议目前公认为本地：<code>file</code>, <code>*-extension</code>, and <code>widget</code>。如果<code>isLocal</code>设置需要修改，建议在<code>$.ajaxSetup()</code>方法中这样做一次。 <span class="version-details"> (1.5 新增 ）</span> 
						</div>
					</li>
					<li>
						<div>
							<strong>jsonp</strong> 
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader0">String</a> 或者 <a href="http://www.shouce.ren/api/view/a/13081#articleHeader14">Boolean</a> 
						</div>
						<div>
							在一个JSONP请求中重写回调函数的名字。这个值用来替代在"callback=?"这种GET或POST请求中URL参数里的"callback"部分，比如{jsonp:'onJsonPLoad'}会导致将"onJsonPLoad=?"传给服务器。<strong>在jQuery 1.5，</strong>，设置<code>jsonp</code>选项为<code>false</code>，阻止了jQuery从加入"?callback"字符串的URL或试图使用"=?"转换。在这种情况下，你也应该明确设置<code>jsonpCallback</code>设置。例如, <code>{ jsonp: false, jsonpCallback: "callbackName" }</code>。如果你不信任你的Ajax请求的目标，出于安全原因，
                      考虑 设置<code>jsonp</code> 属性为<code>false</code>。
						</div>
					</li>
					<li>
						<div>
							<strong>jsonpCallback</strong> 
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader0">String</a>, Function
						</div>
						<div>
							为jsonp请求指定一个回调函数名。这个值将用来取代jQuery自动生成的随机函数名。这主要用来让jQuery生成一个独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。你也可以在想让浏览器缓存GET请求的时候，指定这个回调函数名。<strong>从jQuery 1.5开始，</strong>你也可以使用一个函数作为该参数设置，在这种情况下，该函数的返回值就是<code>jsonpCallback</code>的结果。
						</div>
					</li>
					<li>
						<div>
							<strong>method</strong> (default: <code>'GET'</code>)
						</div>
						<div>
							Type: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader0">String</a> 
						</div>
						<div>
							HTTP 请求方法 (比如：<code>"POST"</code>, <code>"GET
                          "</code>, <code>"PUT"</code>)。<span class="version-details"> (添加版本: 1.9.0)</span>。（手册网注：如果你使用jQuery 1.9.0 之前的版本，你需要使用<code>type</code>选项。）
						</div>
					</li>
					<li>
						<div>
							<strong>mimeType</strong> 
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader0">String</a> 
						</div>
						<div>
							一个mime类型用来覆盖<abbr title="XMLHttpRequest">XHR</abbr>的 MIME类型。<span class="version-details"> (1.5 新增 ）</span> 
						</div>
					</li>
					<li>
						<div>
							<strong>password</strong> 
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader0">String</a> 
						</div>
						<div>
							用于响应HTTP访问认证请求的密码
						</div>
					</li>
					<li>
						<div>
							<strong>processData</strong> (默认: <code>true</code>)
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader14">Boolean</a> 
						</div>
						<div>
							默认情况下，通过<code>data</code>选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型   "application/x-www-form-urlencoded"。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 <code>false</code>。
						</div>
					</li>
					<li>
						<div>
							<strong>scriptCharset</strong> 
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader0">String</a> 
						</div>
						<div>
							仅适用于当"script"传输使用时（例如，跨域的"jsonp"或 dataType选项为"script" 和 "GET"类型）。请求中使用在script标签上设置<code>charset</code> 属性。通常只在本地和远程的内容编码不同时使用。
						</div>
					</li>
					<li>
						<div>
							<strong>statusCode</strong> (默认: <code>{}</code>)
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader25">PlainObject</a> 
						</div>
						<div>
							<p>
								一个 HTTP响应状态码 和 当请求响应相应的状态码时执行的函数 组成的对象。例如： 下面的代码将在http响应状态码为404时弹出“page not found”。
							</p>
							<div class="syntaxhighlighter javascript nogutter">
<pre class="prettyprint lang-js">$.ajax({
  statusCode: {
    404: function() {
      alert("page not found");
    }
  }
});</pre>
							</div>
							<p>
								如果请求成功，响应状态代码对应的函数会带着<code>success</code>回调函数相同的参数；如果请求结果是错误的（包含3xx之类的重定向），他们会采用<code>error</code>回调函数相同的参数。
							</p>
<span class="version-details"> (1.5 新增 ）</span> 
						</div>
					</li>
					<li>
						<div>
							<strong>success</strong> 
						</div>
						<div>
							Type: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader28">Function</a>( Anything data, String textStatus, jqXHR jqXHR )
						</div>
						<div>
							请求成功后的回调函数。这个函数传递3个参数：从服务器返回的数据，并根据dataType参数进行处理后的数据或<code>dataFilter</code>回调函数，如果指定的话；一个描述状态的字符串;还有 jqXHR（在jQuery 1.4.x前为XMLHttpRequest） 对象 。<strong>在jQuery 1.5，</strong> <em>成功设置可以接受一个函数数组。每个函数将被依次调用。</em>这是一个 <a href="http://docs.jquery.com/Ajax_Events">Ajax Event</a> 
						</div>
					</li>
					<li>
						<div>
							<strong>timeout</strong> 
						</div>
						<div>
							类型: Number
						</div>
						<div>
							设置请求超时时间（毫秒）。此设置将覆盖<a href="http://www.shouce.ren/api/view/a/12874" target="_blank">$.ajaxSetup()</a> 里的全局设置。
                        超时周期开始于<code>$.ajax</code> 访问成功的那个时间点；如果几个其他请求都在进步并且浏览器有没有可用的连接，它有可能在被发送前就超时了。<strong>在 jQuery 1.4.x 和前面的版本中,</strong> 如果请求超时，XMLHttpRequest对象是处于无效状态;访问任何对象的成员可能会抛出一个异常。<strong>只有在 Firefox 3.0+,</strong>script 和 JSONP请求在超时后不能被取消;该脚本将运行即使超时后到达。
						</div>
					</li>
					<li>
						<div>
							<strong>traditional</strong> 
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader14">Boolean</a> 
						</div>
						<div>
							如果你想要用传统的方式来序列化数据，那么就设置为<code>true</code>。请参考工具分类下面的<a href="http://www.shouce.ren/api/view/a/13027" class="book-a">jQuery.param </a>方法.
						</div>
					</li>
					<li>
						<div>
							<strong>type</strong> (默认: <code>'GET'</code>)
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader0">String</a> 
						</div>
						<div>
							<code>method</code>选项的别名。如果你使用jQuery 1.9.0 之前的版本，你需要使用<code>type</code>选项。
						</div>
					</li>
					<li>
						<div>
							<strong>url</strong> (默认: <code>当前页面地址</code>)
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader0">String</a> 
						</div>
						<div>
							发送请求的地址。
						</div>
					</li>
					<li>
						<div>
							<strong>username</strong> 
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader0">String</a> 
						</div>
						<div>
							于响应HTTP访问认证请求的用户名
						</div>
					</li>
					<li>
						<div>
							<strong>xhr</strong> (默认: <code>当可用的ActiveXObject（IE）中，否则为XMLHttpRequest</code>)
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader28">Function</a>()
						</div>
						<div>
							回调创建XMLHttpRequest对象。当可用时默认为ActiveXObject（IE）中，否则为XMLHttpRequest。提供覆盖你自己的执行的XMLHttpRequest或增强工厂。
						</div>
					</li>
					<li>
						<div>
							<strong>xhrFields</strong> 
						</div>
						<div>
							类型: <a href="http://www.shouce.ren/api/view/a/13081#articleHeader25">PlainObject</a> 
						</div>
						<div>
							<p>
								一对“文件名-文件值”组成的映射，用于设定原生的 <code><abbr title="XMLHttpRequest">XHR</abbr></code>对象。例如，如果需要的话，在进行跨域请求时，你可以用它来设置<code>withCredentials</code>为<code>true</code>。
							</p>
							<div class="syntaxhighlighter javascript nogutter">
<pre class="prettyprint lang-js">$.ajax({
   url: a_cross_domain_url,
   xhrFields: {
      withCredentials: true
   }
});</pre>
							</div>
							<p>
								<strong>在 jQuery 1.5中</strong>，<code> withCredentials</code>属性不会传递给原生的<code>XHR</code>从而对于需要使用此属性的 CORS 请求，则只能忽略这个属性。。出于这个原因，我们建议您使用jQuery1.5.1+，如果您需要使用它。
							</p>
<span class="version-details"> (1.5.1新增)</span> 
						</div>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
<div class="longdesc" id="entry-longdesc">
	<p>
		jQuery 发送的所有 Ajax 请求，内部都会通过调用 <code>$.ajax()</code> 函数来实现。通常没有必要直接调用这个函数，可以使用几个已经封装的简便方法，如<a href="http://www.shouce.ren/api/view/a/12863" class="book-a"><code>$.get()</code></a>和<a href="http://www.shouce.ren/api/view/a/12862" class="book-a"><code>.load()</code></a>。如果你需要用到那些不常见的选项，那么， <code>$.ajax()</code>使用起来更灵活。
	</p>
	<p>
		在简单地说， <code>$.ajax()</code>函数可以不带参数调用：
	</p>
	<div class="syntaxhighlighter javascript nogutter">
<pre class="prettyprint lang-js">$.ajax();</pre>
	</div>
	<p>
		<strong>注意:</strong> 所有的选项都可以通过<code><a href="http://www.shouce.ren/api/view/a/12874" class="book-a">$.ajaxSetup()</a></code> 函数来全局设置
	</p>
	<p>
		这个示例中，不使用选项，加载当前页面的内容，但其结果没用的。若要使用结果，我们可以实现的回调功能之一。
	</p>
	<h4 id="jqXHR">
		jqXHR 对象
	</h4>
	<p>
		<strong>从jQuery 1.5开始</strong>，<code>$.ajax()</code> 返回XMLHttpRequest（jqXHR）对象，该对象是浏览器的原生的XMLHttpRequest对象的一个超集。例如，它包含<code>responseText</code>和<code>responseXML</code>属性，以及一个<code>getResponseHeader()</code>方法。当传输机制不是是XMLHttpRequest时（例如，一个JSONP请求脚本，返回一个脚本 tag 时），jqXHR对象尽可能的模拟原生的XHR功能。
	</p>
	<p>
		<strong>从jQuery 1.5.1开始</strong>， <code>jqXHR</code>对象还包含了<code>overrideMimeType</code>方法 (它在jQuery 1.4.x中是有效的，但是在jQuery 1.5中暂时的被移除)。<code>.overrideMimeType()</code> 方法可能用在<code>beforeSend()</code>的回调函数中，例如，修改响应的Content-Type信息头：
	</p>
	<div class="syntaxhighlighter javascript nogutter">
<pre class="prettyprint lang-js">$.ajax({
  url: "http://fiddle.jshell.net/favicon.png",
  beforeSend: function ( xhr ) {
    xhr.overrideMimeType("text/plain; charset=x-user-defined");
  }
}).done(function ( data ) {
  if( console &amp;&amp; console.log ) {
    console.log("Sample of data:", data.slice(0, 100));
  }
});</pre>
	</div>
	<p>
		从 jQuery 1.5 开始，<code>$.ajax()</code>返回的jqXHR对象 实现了 Promise 接口, 使它拥有了 Promise 的所有属性，方法和行为。为了让回调函数的名字统一，便于在<code>$.ajax()</code>中使用。jqXHR也提供<code>.error()</code> <code>.success()</code>和<code>.complete()</code>方法。这些方法都带有一个参数，该参数是一个函数，此函数在 <code>$.ajax()</code>请求结束时被调用,并且这个函数接收的参数，与调用 <code>$.ajax()</code>函数时的参数是一致。这将允许你在一次请求时，对多个回调函数进行赋值，甚至允许你在请求已经完成后，对回调函数进行赋值(如果该请求已经完成，则回调函数会被立刻调用)。
	</p>
	<ul>
		<li>
			<strong>jqXHR.done(function(data, textStatus, jqXHR) {});</strong> 
			<p>
				一个可供选择的 success 回调选项的构造函数，<del><code>.done()</code>方法取代了的过时的<code>jqXHR.success()</code>方法。</del>请参阅<code><a href="http://www.shouce.ren/api/view/a/13048" class="book-a">deferred.done()</a></code>的实现细节。
			</p>
		</li>
		<li>
			<strong>jqXHR.fail(function(jqXHR, textStatus, errorThrown) {});</strong> 
			<p>
				一种可供选择的 error 回调选项的构造函数，<code>.fail()</code>方法取代了的过时的<code>.error()</code>方法。请参阅<code><a href="http://www.shouce.ren/api/view/a/13049" class="book-a">deferred.fail()</a></code>的实现细节。
			</p>
		</li>
		<li>
			<strong>jqXHR.always(function(data|jqXHR, textStatus, jqXHR|errorThrown) { });（在jQuery 1.6 中添加）</strong> 
			<p>
				一种可供选择的 complete 回调选项的构造函数，<code>.always()</code>方法取代了的过时的<code>.complete()</code>方法。
			</p>
			<p>
				在响应一个成功的请求后，该函数的参数和<code>.done()</code>的参数是相同的：data, textStatus, 和 jqXHR 对象.对于失败的请求，参数和<code>.fail()</code>的参数是相同的：jqXHR 对象, textStatus, 和 errorThrown。请参阅<code><a href="http://www.shouce.ren/api/view/a/13059" class="book-a">deferred.always()</a></code>的实现细节。
			</p>
		</li>
		<li>
			<strong>jqXHR.then(function(data, textStatus, jqXHR) {}, function(jqXHR, textStatus, errorThrown) {});</strong> 
			<p>
				包含了 <code>.done()</code> 和 <code>.fail()</code>方法的功能，（从 jQuery 1.8 开始）允许底层被操纵。请参阅<code><a href="http://www.shouce.ren/api/view/a/13056" class="book-a">deferred.then()</a></code>的实现细节。
			</p>
		</li>
	</ul>
	<div class="warning">
		<p>
			<strong>推荐使用的注意事项:</strong> <code>jqXHR.success()</code>, <code>jqXHR.error()</code>, 和 <code>jqXHR.complete()</code>回调<del>从 jQuery 1.8开始 被弃用过时。他们将最终被取消，您的代码应做好准备，</del> 从jQuery 3.0开始被删除，你可以使用<code>jqXHR.done()</code>, <code>jqXHR.fail()</code>, 和 <code>jqXHR.always()</code> 代替。
		</p>
	</div>
	<div class="syntaxhighlighter javascript nogutter">
<pre class="prettyprint lang-js">// Assign handlers immediately after making the request,
// and remember the jqxhr object for this request
var jqxhr = $.ajax( "example.php" )
    .done(function() { alert("success"); })
    .fail(function() { alert("error"); })
    .always(function() { alert("complete"); });
 
// perform other work here ...
 
// Set another completion function for the request above
jqxhr.always(function() { alert("second complete"); });</pre>
	</div>
	<p>
		<code>this</code>在所有的回调中的引用，是这个对象在传递给<code>$.ajax</code>的设置中上下文；如果没有指定<code>context（上下文）</code>，<code>this</code> 引用的是Ajax设置的本身。
	</p>
	<p>
		为了向后兼容<code>XMLHttpRequest</code> ，一<code>jqXHR</code>对象将公开下列属性和方法：
	</p>
	<ul>
		<li>
			<code>readyState</code> 
		</li>
		<li>
			<code>status</code> 
		</li>
		<li>
			<code>statusText</code> 
		</li>
		<li>
			<code>responseXML</code> and/or <code>responseText</code> 当底层的请求分别作出XML和/或文本响应
		</li>
		<li>
			<code>setRequestHeader(name, value)</code> 从标准出发，通过替换旧的值为新的值，而不是替换的新值到旧值
		</li>
		<li>
			<code>getAllResponseHeaders()</code> 
		</li>
		<li>
			<code>getResponseHeader()</code> 
		</li>
		<li>
			<code>abort()</code> 
		</li>
	</ul>
	<p>
		假如没有<code>onreadystatechange</code>属性，因为不同的状态可以分别在 <code>success</code> ， <code>error</code> ， <code>complete</code>和<code>statusCode</code> 方法中进行处理。
	</p>
	<h4 id="callback-functions">
		Callback Function Queues（回调函数）
	</h4>
	<p>
		<code>beforeSend</code>, <code>error</code>, <code>dataFilter</code>, <code>success</code> 和 <code>complete</code>接受的回调函数是在合适的时间调用。
	</p>
	<p>
		<strong>从jQuery 1.5开始，</strong> <code>fail</code> ， <code>done</code> ，和从jQuery 1.6开始的<code>always</code>回调钩子（hooks）采用先入先出队列管理。这意味着你可以为每个挂钩分配多个回调。这是实现内部的<code>$.ajax()</code>回调钩子（hooks）。
	</p>
	<p>
		这里有<code>$.ajax()</code>提供的回调钩子 （hooks），如下：
	</p>
	<ol>
		<li>
			beforeSend 在发送请求之前调用，它接收<code>jqXHR</code>对象和<code>settings</code>作为参数对象。
		</li>
		<li>
			error 在请求出错时调用。如果请求失败，在它们的顺序依次登记。他们接受<code>jqXHR</code> ，字符串表示的错误类型，以及异常对象（如果有的话）。一些内置的错误会将 "abort", "timeout", "No Transport" 等字符串作为异常对象。
		</li>
		<li>
			<code>dataFilter</code> 在请求成功之后调用。传入返回的数据以及<code>dataType</code>参数的值。并且必须返回新的数据（可能是处理过的）传递给<code>success</code>回调函数。
		</li>
		<li>
			<code>success</code> 当请求成功并接收到返回数据之后调用。传入返回后的数据，以及包含成功代码的字符串和<code>jqXHR</code>对象。
		</li>
		<li>
			<strong>Promise callbacks</strong> — <code>.done()</code>, <code>.fail()</code>, <code>.always()</code>, and <code>.then()</code> — 根据他们注册的顺序被调用。
		</li>
		<li>
			<code>complete</code> 请求完成时，无论是在失败或成功，它们按顺序依次执行回调。他们收到<code>jqXHR</code>对象，以及一个包含成功或错误代码。
		</li>
	</ol>
	<h4 id="data-types">
		Data Types（数据类型）
	</h4>
	<p>
		<code>$.ajax()</code>调用不同类型的响应，被传递到成功处理函数之前，会经过不同种类的预处理。 预处理的类型取决于由更加接近默认的Content-Type响应，但可以明确使用<code>dataType</code>选项进行设置。如果提供了<code>dataType</code>选项，  响应的Content-Type头信息将被忽略。
	</p>
	<p>
		有效的数据类型是<code>text</code>， <code>html</code>， <code>xml</code>， <code>json</code>，<code>jsonp</code>，和 <code>script</code>.
	</p>
	<p>
		如果指定的是<code>text</code> 或 <code>html</code>， 则不会预处理。
                这些数据被简单地传递给成功处理函数，
                并通过该<code>jqXHR</code>对象的<code>responseText</code>属性获得的。
	</p>
	<p>
		如果指定的是<code>xml</code>，
                响应结果作为<a href="http://www.shouce.ren/api/view/a/13081#articleHeader44"><code>XMLDocument</code></a>，在传递给成功处理函数之前使用<a href="http://www.shouce.ren/api/view/a/13015" class="book-a"><code>jQuery.parseXML</code></a>进行解析。
                XML文档是可以通过该<code>jqXHR</code>对象的<code>responseXML</code>属性获得的。
	</p>
	<p>
		如果指定的是<code>json</code>，响应结果作为一个对象，在传递给成功处理函数之前使用<a href="http://www.shouce.ren/api/view/a/13014" class="book-a"><code>jQuery.parseJSON</code></a>进行解析。 解析后的JSON对象可以通过该<code>jqXHR</code>对象的<code>responseJSON</code>属性获得的。
	</p>
	<p>
		如果指定的是<code>script</code> ，<code>$.ajax()</code> 执行这段 JavaScript，这段 JavaScript 从服务器接收到，在传递给成功处理函数之前是一个字符串。
	</p>
	<p>
		如果指定的是<code>jsonp</code> ，<code>$.ajax()</code>会自动在请求的URL后面增加一个查询字符串参数 <code>callback=?</code>（默认） 。传递给<code>$.ajax()</code> 设置中的<code>jsonp</code> 和 <code>jsonpCallback</code>属性可以被用来指定，
 分别为 
查询字符串参数的名称和JSONP回调函数的名称。服务器应返回有效的JavaScript，传递JSON响应到回调函数（手册网注：例如，flightHandler({"code":
 "CA1998","price": 1780,"tickets": 5});等）。 在包含JSON对象的相应结果传递给成功处理函数之前，<code>$.ajax()</code> 将执行返回的JavaScript， 调用JSONP回调函数。
	</p>
	<p>
		更多JSONP信息可以参阅<a href="http://bob.ippoli.to/archives/2005/12/05/remote-json-jsonp/">详细介绍了其使用的原帖</a>.
	</p>
	<h4 id="sending-data-to-server">
		Sending Data to the Server（发送数据到服务器）
	</h4>
	<p>
		默认情况下，Ajax请求使用GET方法。如果要使用POST方法，可以设定<code>type</code>参数值。这个选项也会影响 <code>data</code> 选项中的内容如何发送到服务器。POST数据将被发送到服务器使用UTF-8字符集，根据W3C XMLHttpRequest的标准。
	</p>
	<p>
		data选项既可以包含一个查询字符串，比如 <code>key1=value1&amp;key2=value2</code>，也可以是一个映射，比如 <code>{key1: 'value1', key2: 'value2'}</code> 。如果使用了后者的形式，则数据再发送前会用<code><a href="http://www.shouce.ren/api/view/a/13027" class="book-a">jQuery.param()</a></code> 将其转换成查询字符串。这个处理过程也可以通过设置<code>processData</code>选项为<code>false</code>来回避。如果我们希望发送一个XML对象给服务器时，这种处理可能并不合适。并且在这种情况下，我们也应当改变<code>contentType</code> 选项的值，用其他合适的MIME类型来取代默认的 <code>application/x-www-form-urlencoded</code> 。
	</p>
	<h4 id="advanced-options">
		Advanced Options（高级选项）
	</h4>
	<p>
		global选项用于阻止响应注册的回调函数，比如<code><a href="http://www.shouce.ren/api/view/a/12869" class="book-a">.ajaxSend()</a></code>, <code><a href="http://www.shouce.ren/api/view/a/12868" class="book-a">.ajaxError()</a></code>，以及类似的方法。这在有些时候很有用，比如发送的请求非常频繁且简短的时候，就可以在<code><a href="http://www.shouce.ren/api/view/a/12869" class="book-a">.ajaxSend()</a></code>里禁用这个。跨域脚本和JSONP请求，全局选项自动设置为<code>false</code>。更多关于这些方法的详细信息，请参阅下面的内容。
	</p>
	<p>
		如果服务器需要HTTP认证，可以使用用户名和密码可以通过 <code>username</code> 和 <code>password</code> 选项来设置。
	</p>
	<p>
		Ajax请求是限时的，所以错误警告被捕获并处理后，可以用来提升用户体验。请求超时这个参数通常就保留其默认值，要不就通过<code><a href="http://www.shouce.ren/api/view/a/12874" class="book-a">$.ajaxSetup()</a></code>来全局设定，很少为特定的请求重新设置<code>timeout</code>选项。
	</p>
	<p>
		默认情况下，请求总会被发出去，但浏览器有可能从他的缓存中调取数据。要禁止使用缓存的结果，可以设置<code>cache</code>参数为<code>false</code>。如果希望判断数据自从上次请求后没有更改过就报告出错的话，可以设置<code>ifModified</code>为<code>true</code>。
	</p>
	<p>
		<code>scriptCharset</code>允许给&lt;script&gt;标签的请求设定一个特定的字符集，用于<code>script</code> 或者 <code>jsonp</code>类似的数据。当脚本和页面字符集不同时，这特别好用。
	</p>
	<p>
		Ajax的第一个字母是“asynchronous”的开头字母，这意味着所有的操作都是并行的，完成的顺序没有前后关系。<code>$.ajax()</code>的<code>async</code>参数总是设置成<code>true</code>，这标志着在请求开始后，其他代码依然能够执行。强烈不建议把这个选项设置成<code>false</code>，这意味着所有的请求都不再是异步的了，这也会导致浏览器被锁死。
	</p>
	<p>
		<code>$.ajax()</code>函数返回他创建的<code>XMLHttpRequest</code>对象。通常jQuery只在内部处理并创建这个对象，但用户也可以通过<code>xhr</code> 选项来传递一个自己创建的xhr对象。返回的对象通常已经被丢弃了，但依然提供一个底层接口来观察和操控请求。比如说，调用对象上的<code>.abort()</code> 可以在请求完成前挂起请求。
	</p>
	<p>
		<strong>目前</strong>, 在Firefox中有一个bug，虽然<code>.getResponseHeader('Content-Type')</code>返回一个非空的字符串，但是 <code>.getAllResponseHeaders()</code>还是返回空字符串， 在Firefox中使用jQuery不支持自动解码JSON CORS 响应。
	</p>
	<p>
		重写<code>jQuery.ajaxSettings.xhr</code> 的一种解决方案，如下
	</p>
	<div class="syntaxhighlighter javascript nogutter">
<pre class="prettyprint lang-js">(function () {
  var _super = jQuery.ajaxSettings.xhr,
    xhrCorsHeaders = [ "Cache-Control", "Content-Language", "Content-Type", "Expires", "Last-Modified", "Pragma" ];
 
  jQuery.ajaxSettings.xhr = function () {
    var xhr = _super(),
      getAllResponseHeaders = xhr.getAllResponseHeaders;
 
    xhr.getAllResponseHeaders = function () {
      var allHeaders = "";
      try {
        allHeaders = getAllResponseHeaders.apply( xhr );
        if ( allHeaders ) {
          return allHeaders;
        }
      } catch ( e ) {
      }
 
      $.each( xhrCorsHeaders, function ( i, headerName ) {
        if ( xhr.getResponseHeader( headerName ) ) {
          allHeaders += headerName + ": " + xhr.getResponseHeader( headerName ) + "\n";
        }
      });
      return allHeaders;
    };
 
    return xhr;
  };
})();</pre>
	</div>
	<h4 id="extending-ajax">
		Extending Ajax（扩展 Ajax）
	</h4>
	<p>
		<strong>从jQuery 1.5开始，</strong>，jQuery的Ajax实现包括预<a href="http://www.shouce.ren/api/view/a/12873" class="book-a">prefilters</a>, <a href="http://www.shouce.ren/api/view/a/13083" class="book-a">transports</a>和传输，让您更加灵活的扩展Ajax。如需有关这些先进功能的信息。
	</p>
	<h4 id="using-converters">
		Using Converters（使用转换器）
	</h4>
	<p>
		<code>$.ajax()</code>的转换器支持的数据类型映射到其它数据类型。但是，如果你想把自定义数据类型映射到一个已知的类型（<code>json</code>等）,您必须<code>contents</code> 选项在响应的Content-Type和实际的数据类型之间的添加一个相关的转换函数：
	</p>
	<div class="syntaxhighlighter javascript nogutter">
<pre class="prettyprint lang-js">$.ajaxSetup({
  contents: {
    mycustomtype: /mycustomtype/
  },
  converters: {
    "mycustomtype json": function ( result ) {
      // do stuff
      return newresult;
    }
  }
});</pre>
	</div>
	<p>
		这额外的对象是必要的，因为响应内容类型(Content-Types)和数据类型从来没有一个严格的一对一对应关系（正则表达式表示结果）。
	</p>
	<p>
		转换一个支持的类型（例如<code>text</code>, <code>json</code>）成自定义数据类型，然后再返回，使用另一个直通转换器：
	</p>
	<div class="syntaxhighlighter javascript nogutter">
<pre class="prettyprint lang-js">$.ajaxSetup({
  contents: {
    mycustomtype: /mycustomtype/
  },
  converters: {
    "text mycustomtype": true,
    "mycustomtype json": function ( result ) {
      // do stuff
      return newresult;
    }
  }
});</pre>
	</div>
	<p>
		现在上面的代码允许通过从<code>text</code> 为<code>mycustomtype</code> ，进而，<code>mycustomtype</code> 转换为 <code>json</code>。
	</p>
</div>
<h3>
	Additional Notes:（其他注意事项：）
</h3>
<div class="longdesc">
	<ul>
		<li>
			由于浏览器的安全限制，大多数“Ajax”的要求，均采用<a title="维基百科上的同源策略" href="http://en.wikipedia.org/wiki/Same_origin_policy">同一起源的政策</a> ;该请求不能成功地检索来自不同的域，子域或协议的数据。
		</li>
		<li>
			Script和JSONP形式请求不受同源策略的限制。
		</li>
	</ul>
</div>
<div class="example">
	<h3>
		<blockquote>
			示例
		</blockquote>
	</h3>
	<h4>
		实例 <br />
	</h4>
	<p>
		保存数据到服务器，成功时显示信息。
	</p>
<pre class="prettyprint lang-js">$.ajax({
  method: "POST",
  url: "some.php",
  data: { name: "John", location: "Boston" }
}).done(function( msg ) {
  alert( "Data Saved: " + msg );
});</pre>
	<h4>
		实例
	</h4>
	<p>
		装入一个 HTML 网页最新版本。
	</p>
<pre class="prettyprint lang-js">$.ajax({
  url: "test.html",
  cache: false
}).done(function( html ) {
  $("#results").append(html);
});</pre>
	<h4>
		实例
	</h4>
	<p>
		发送 XML 数据至服务器。设置 processData 选项为 false，防止自动转换数据格式。
	</p>
<pre class="prettyprint lang-js">var xmlDocument = [create xml document];
var xmlRequest = $.ajax({
  url: "page.php",
  processData: false,
  data: xmlDocument
});
 
xmlRequest.done(handleResponse);</pre>
	<h4>
		实例
	</h4>
	<p>
		发送id作为数据发送到服务器， 保存一些数据到服务器上， 并通一旦它的完成知用户。&nbsp; 如果请求失败，则提醒用户。
	</p>
<pre class="prettyprint lang-js">var menuId = $("ul.nav").first().attr("id");
var request = $.ajax({
  url: "script.php",
  method: "POST",
  data: {id : menuId},
  dataType: "html"
});
 
request.done(function(msg) {
  $("#log").html( msg );
});
 
request.fail(function(jqXHR, textStatus) {
  alert( "Request failed: " + textStatus );
});</pre>
	<h4>
		实例
	</h4>
	<p>
		载入并执行一个JavaScript文件.
	</p>
<pre class="prettyprint lang-js">$.ajax({
  method: "GET",
  url: "test.js",
  dataType: "script"
});</pre>
</div></div>
<div class="m-bg text-center margin_t_1">
	<a class="btn btn-sm btn-default" href="http://www.shouce.ren"><strong>手册网</strong></a>
</div>
<script type="text/javascript">
$(function(){
	$("pre").addClass("prettyprint linenums");
	//代码高亮
	prettyPrint();
	$("table").attr('class','table table-striped table-bordered table-condensed');
});
</script>
</body>
</html>
