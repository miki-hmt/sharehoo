<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
    <title>坦克大战--练习版 </title>
<style type="text/css">
	.mapBorder{position:absolute;left:0;top:0;z-index:9999;width:520px;height:520px;}
.mapBorder span{width:40px;height:40px;overflow:hidden;display:block; float:left;}
	#divMap
	{
		position:absolute;background:#000; 
		border:10px outset #C65D05;
		width:540px;height:540px;
	}

	.steel
	{
		background:url(img/steel.gif) ;
	}
	.tod
	{
		background:url(img/tod.gif) ;
	}
	.wall
	{
		background:url(img/wall.gif) ;
	}
	.river
	{
		background:url(img/sea.gif) ; 
	}
	.podium
	{
		background:url(img/podium.gif) ;
	}
	.itank{
		background:url(img/itank.gif) no-repeat ;   
		position:absolute;
		width:40px;
		height:40px;
		overflow:hidden;
		z-index:100;
		left:20px;
		top:240px;
	}
	.etank{
		background:url(img/etank.gif) no-repeat;   
		position:absolute;
		width:40px;
		height:40px;
		overflow:hidden;
		z-index:100;

	}
	.bomb
	{
		background:url(img/ball.gif) no-repeat;   
		position:absolute;
		width:40px;
		height:40px;
		overflow:hidden;
		left:-9000px;
	}
	.explode
	{
		position:absolute;
		width:60px;
		height:60px;
		overflow:hidden;
		background:url(img/explode.gif) no-repeat 0 0;
		z-index:10000;
	}

	
	.cellwidth
	{
		width:40px;
		height:40px;
	}
	body
	{
		background:black;
		margin:0px;
		padding:0px;
	}
	#debugInfo
	{
		color:white;
		background-color:blue;
		position:absolute;
		left:700px;
		top:100px;
		overflow:auto;
		width:400px;
		height:300px;
	}

</style>
</head>
<body >
    
    <!--地图容器-->
				<div id="divMap">
                </div>
				<div id="debugInfo">
				</div>
    <script>
  /*系统变量*/
		
		//地图元素类型枚举
        /*
        0：空地	
        1：墙	
        2：钢	
        3：树丛		
        4：河		
        5：总部	
        */
        var EnumMapCellType = { 
			Empty:			'0'
			, Wall:			'1'
			, Steel:		'2'
			, Tod:			'3'
			, River:		'4'
			, Podium:		'5'
 
		};
		var EnumDirection={
			Up:				'0'
			,Right:			'1'
			,Down:			'2'
			,Left:			'3'
		};
		/*
			地图上每一个格子上停放的物品类型
		
		var EnumCellParkType={
			Tank:			'0'
			,Bomb:			'1'
			,Goods:			'2'
			,Barrier:		'3'
		}
		*/
		var ArrayCss=['empty','wall','steel','tod','river','podium']

       
		/*关卡*/
		var str=  '0000000000000';
			str+=',0011100111010';
			str+=',1000010000200';
			str+=',1200333310101';
			str+=',0000444400001';
			str+=',3313300001011';
			str+=',3011331022011';
			str+=',3311031011011';
			str+=',0101011102010';
			str+=',0101011010010';
			str+=',0100000000110';
			str+=',0100012101101';
			str+=',0010015100000';

		var Top_MapLevel = [str];

		
  /*系统变量*/



		//通用方法对象
		var UtilityClass={
			CreateE:function(type,id,className,parentNode)
			{
				var J=document.createElement(type);
				if(id)J.id=id;
				if(className)J.className=className;
				return parentNode.appendChild(J);
			}
			,RemoveE:function(obj,parentNode)
			{
				//Debug.Trace(parentNode);
				parentNode.removeChild(obj);
			}
			,GetFunctionName:function(context,argumentCallee)
			{
				for(var i in context)if(context[i]==argumentCallee)return i;
				return "";
			}
			,BindFunction:function(obj,func)
			{
				return function(){
					func.apply(obj,arguments);
				};
			}
		}
		//调试
		var Debug={
			Trace:function(str)
			{
				var d=document.createElement("div");
				d.innerHTML=str + "---time:" + (new Date()).getTime();

				document.getElementById("debugInfo").appendChild(d);
			}

		}
	   //爆炸效果类
		Explode=function()
		{
			this.container=document.getElementById("divMap");
			this.UI=null;
			this.step=8;
			this.speed=50;
		}
		Explode.prototype.Play=function(x,y)
		{
			this.UI=UtilityClass.CreateE("div","","explode",this.container);
			this.MoveTo(x,y);

			var i=0;
			var This=this;
			var FxTimer=setInterval(function (){
				This.UI.style.backgroundPosition='0 -'+i++*60+'px';
				if(i==This.step){
					clearInterval(FxTimer);
					This.Stop();
				}
			},This.speed)
		}
		//x:1*40,...
		Explode.prototype.MoveTo=function(x,y)
		{
			if(this.UI!=null)
			{
				this.UI.style.left=x*40+(-10)+"px";
				this.UI.style.top=y*40+(-10)+"px";
			}
		}
		Explode.prototype.Stop=function()
		{
			UtilityClass.RemoveE(this.UI,this.container);
		}
		//坦克大战顶层对象
		TankObject=function()
		{
			this.AttackVal=0;
			this.DefendVal=0;
			this.CanBeAttacked=false;
			this.XPosition=0;
			this.YPosition=0;
			this.CanAcross=false;
			this.UI=null; //坦克大战一个格子对象的UI
		}
		TankObject.prototype.UpdateUI=function(battlField){}
		//设置位置，参数是这样：1*40,6*40
		TankObject.prototype.SetPosition=function(leftPosition,topPosition)
		{
			
			this.XPosition=Math.round(leftPosition/40);
			this.YPosition=Math.round(topPosition/40);

			if(this.UI!=null && this.UI.style!=null)
			{

				this.UI.style.left=leftPosition+"px";
				this.UI.style.top=topPosition+"px";
			}
		}


		//碰撞检测对象
		HitTestObject=function()
		{
		}
		HitTestObject.prototype=new TankObject();
		
		HitTestObject.prototype.HitTest=function(battleField)
		{
			//to be implemented
			//throw new Error("请实现"+UtilityClass.GetFunctionName(this,arguments.callee)+"方法");

			var nextObj=this.GetNextBattleFieldCell(battleField);
			//Debug.Trace(nextObj instanceof Barrier);
			//if(nextObj instanceof Bomb)
				//Debug.Trace(this.XPosition+"--"+this.YPosition);
			
			if(nextObj==null)
			{
				return true;//场景越界
			}
			//检测是否是障碍物
			if(nextObj.obj instanceof Barrier)
			{
				 if(nextObj.obj instanceof EmptyB)
				 {
					 if(nextObj.occupier instanceof Bomb)
					 {
						return nextObj.occupier.Owner instanceof EnimyTank;
					 }

					 return nextObj.occupier instanceof Mover;
				 }
				 //如果是炮弹碰到河流，就穿过
				 if(this instanceof Bomb && nextObj.obj instanceof RiverB)
					 return false;
				 //Debug.Trace(nextObj.occupier instanceof Mover);
				 return !nextObj.obj.CanAcross;
			}
		}

		HitTestObject.prototype.GetNextBattleFieldCell=function(battleField)
		{
			
			if(this.Direction==EnumDirection.Up&&this.YPosition==0||
				this.Direction==EnumDirection.Right&&this.XPosition==12||
				this.Direction==EnumDirection.Down&&this.YPosition==12||
				this.Direction==EnumDirection.Left&&this.XPosition==0
			)
			return null;/* 场景越界 */

			var y=this.YPosition;
			var x=this.XPosition;
			var nextAxes=this.GetNextAxes(x,y);

				//Debug.Trace("next-y:"+nextAxes.y+"next---x:"+nextAxes.x);
	
			return battleField[nextAxes.y][nextAxes.x];
		}
		//获取下一个坐标
		HitTestObject.prototype.GetNextAxes=function(x,y)
		{
			var point={x:x,y:y};
			switch(this.Direction+""){//这个地方如果不加“”，就不是字符串类型，不等于字符串类型
				case EnumDirection.Up:
					point={x:x,y:y-1};
					break;
				case EnumDirection.Right:
					point={x:x+1,y:y};
					break;
				case EnumDirection.Down:
					point={x:x,y:y+1};
					break;
				case EnumDirection.Left:
					point={x:x-1,y:y};
					break;
			}
			return point;
		}
		HitTestObject.prototype.OnHitTest=function(battleField)
		{
			//to be implemented
			//throw new Error("请实现"+UtilityClass.GetFunctionName(this,arguments.callee)+"方法");
		}

		//移动对象，继承自碰撞检测对象
		Mover=function()
		{
			this.Direction=EnumDirection.Up;
			this.Speed=1;
		}
		Mover.prototype=new HitTestObject();
		Mover.prototype.Move=function(battleField)
		{
			if(this.lock){
				return;}/* 停用或者尚在步进中,操作无效 */
			
			if((this instanceof EnimyTank)&&Math.random()*100>50)/* 敌机有4%的机率会中途变换方向  */
				 this.Direction=Math.max(0,Math.min(3,parseInt(Math.random()*5)-1));

			this.UI.style.backgroundPosition='0 -'+this.Direction*40+'px';
			if(this.HitTest(battleField))return this.OnHitTest(battleField);

			//如果方向是上和下，vp就是top；如果方向是上和左，val就是-1
			var vp=["top","left"][((this.Direction==EnumDirection.Up)||(this.Direction==EnumDirection.Down))?0:1];
			var val=((this.Direction==EnumDirection.Up)||(this.Direction==EnumDirection.Left))?-1:1;

			this.lock=true;/* 加锁 */
			var This=this;
			var startmoveP=parseInt(This.UI.style[vp]);
			var xp=This.XPosition,yp=This.YPosition;
			var nextPoint=this.GetNextAxes(xp,yp);

			var subMove=setInterval(function (){
				
				This.UI.style[vp]=parseInt(This.UI.style[vp])+ 5 *val+'px';
				battleField[nextPoint.y][nextPoint.x].occupier=This;//记录移动物即将占据的下一个在战场上的位置

				if( Math.abs(parseInt(This.UI.style[vp])-startmoveP)>=40)
				{
					clearInterval(subMove);
					This.lock=false;/* 解锁,允许再次步进 */

					This.XPosition=Math.round(This.UI.offsetLeft/40);/* 保存网格坐标 */
					This.YPosition=Math.round(This.UI.offsetTop/40);
					battleField[yp][xp].occupier=null;//清空当前战场占有物


					if(This instanceof Bomb)This.Move(battleField);
				}
				
				
			},80-This.Speed*10);/*60-This.Speed*10*/ /*50是最好的起始速度*/

		}

		//炸弹对象,这个对象需要放在TANK对象前面，有先后顺序
		Bomb=function(){
			this.Owner=null;
			this.Power=1;
			this.Speed=7;
		}
		Bomb.prototype=new Mover();
		Bomb.prototype.Load=function(x,y)
		{
			this.UI=document.getElementById("divMap").appendChild(document.createElement("div"));
			this.UI.className="bomb";
			this.SetPosition(x*40,y*40);
		}

		//重写OnHitTest方法
		Bomb.prototype.OnHitTest=function(battleField)
		{
			var ex=new Explode();
			ex.Play(this.XPosition,this.YPosition);
			this.Owner.BombUsed-=1;
			battleField[this.YPosition][this.XPosition].occupier=null;
			UtilityClass.RemoveE(this.UI,document.getElementById("divMap"));

			var nextObj=this.GetNextBattleFieldCell(battleField);
			if(nextObj==null)
				return;
			nextObj.occupier=null;


			if(nextObj.obj instanceof Barrier)
			{
				//如果可被攻击
				if(nextObj.obj.CanBeAttacked)
				{
					nextObj.obj.DefendVal-=this.Power;
					if(nextObj.obj.DefendVal<=0)
					{
						var to=new EmptyB();
						to.UI=nextObj.obj.UI;
						to.XPosition=nextObj.obj.XPosition;
						to.YPosition=nextObj.obj.YPosition;
						
						nextObj.obj=to;
						
						battleField[this.YPosition][this.XPosition].obj.UI.className="";
					}
				}
			}
			
		}
		//重写HitTest方法
		Bomb.prototype.HitTest=function(battleField)
		{
			var nextObj=this.GetNextBattleFieldCell(battleField);
			//Debug.Trace(nextObj instanceof Barrier);
			//if(nextObj instanceof Bomb)
				//Debug.Trace(this.XPosition+"--"+this.YPosition);
			if(nextObj==null)
			{
				return true;
			}
			//检测是否是障碍物
			if(nextObj.obj instanceof Barrier)
			{
				if(nextObj.obj instanceof EmptyB)
				 {
					 //Debug.Trace("Empty");
					 if(nextObj.occupier instanceof Bomb)
					 {
						//Debug.Trace("Bomb");
						return nextObj.occupier.Owner instanceof EnimyTank;
					 }
					 if(nextObj.occupier instanceof Tank)
					 {
						//Debug.Trace("Tank");
						return nextObj.occupier instanceof EnimyTank;
					 }
				 }
				 //如果是炮弹碰到河流，就穿过
				 if(this instanceof Bomb && nextObj.obj instanceof RiverB)
					 return false;
				 //Debug.Trace(nextObj.occupier instanceof Mover);
				 return !nextObj.obj.CanAcross;
			}

		}

		//tank对象
		Tank=function(){
			this.BombNum=3;
			this.BombUsed=0;
			this.LifeNum=1;
			this.BombArray=[];
			//this.SetBombArray();
		}
		Tank.prototype=new Mover();
		Tank.prototype.SetBombArray=function()
		{
			this.BombArray=[];
			for(var i=0;i<this.BombNum;i++)
			{
				var b=new Bomb();
				this.BombArray.push(b);
			}
		}
		Tank.prototype.Shot=function(battleField){
			if(this.BombUsed>=this.BombNum)return;
			var bomb=new Bomb();
			bomb.Load(this.XPosition,this.YPosition);
			this.BombUsed+=1;
			bomb.Owner=this;
			bomb.Direction=this.Direction;
			bomb.Move(battleField);
		}

		EnimyTank=function(){
			this.UI=document.getElementById("divMap").appendChild(document.createElement("div"));
			this.UI.className="etank";
		}
		EnimyTank.prototype=new Tank();
		EnimyTank.prototype.UpdateUI=function(battleField)
		{
			Tank.prototype.constructor();

			this.UI.className="etank";
			battleField[this.YPosition][this.XPosition].occupier=this;
			this.SetPosition(this.XPosition*40,this.YPosition*40);
		}


		SelfTank=function(){
			this.UI=document.getElementById("divMap").appendChild(document.createElement("div"));
			this.UI.className="itank";
			//坦克是否处于移动状态，通过这个来判断按键是否持续按住
			this.MovingState=false;
			this.Speed=4;

		}
		SelfTank.prototype=new Tank();
		SelfTank.prototype.UpdateUI=function(battleField)
		{
			this.UI.className="itank";
			battleField[this.YPosition][this.XPosition].occupier=this;
			this.SetPosition(this.XPosition*40,this.YPosition*40);
		}


		/*------------------↓↓↓↓↓障碍物对象群↓↓↓↓↓------------------------*/
		//障碍物基类对象
		Barrier=function(){
			this.DefendVal=1;
			this.CanBeAttacked=true;
		}
		Barrier.prototype=new TankObject();

		WallB=function(){}
		WallB.prototype=new Barrier();
		
		EmptyB=function(){
			this.CanAcross=true;
		}
		EmptyB.prototype=new Barrier();

		RiverB=function(){
			this.DefendVal=0;
			this.CanBeAttacked=false;
		}
		RiverB.prototype=new Barrier();

		SteelB=function()
		{
			this.DefendVal=3;
		}
		SteelB.prototype=new Barrier();

		TodB=function(){
			this.CanBeAttacked=false;
			this.DefendVal=0;
			this.CanAcross=true;
		}
		TodB.prototype=new Barrier();

		PodiumB=function()
		{
			this.DefendVal=5;
		}
		PodiumB.prototype=new Barrier();

		/*------------------↑↑↑↑↑障碍物对象群结束线↑↑↑↑↑------------------------*/

  		/*--------------------↓↓↓↓↓↓物品对象群↓↓↓↓↓↓-----------------------*/
		Goods=function()
		{
			this.CanAcross=true;
			this.Price=0;
			this.ValueStep=1;	//步进
			this.IsUsed=false;	//是否已使用
		}
		Goods.prototype=new TankObject();
		//owner:物品的所有者对象，这个只能是TANK
		Goods.prototype.UseGoods=function(owner)
		{
			if(owner instanceof Tank)
				throw new Error("请传TANK对象");
		}

		//炸弹威力物品
		PowerG=function(){this.Price=2;}
		PowerG.prototype=new Goods();
		PowerG.prototype.UseGoods=function(owner)
		{
			//调用父类方法
			Goods.prototype.UseGoods.call(this,owner);
			for(var i=0;i<owner.BombArray.length;i++)
			{
				owner.BombArray[i].Power+=this.ValueStep;				
			}
		}

		SpeedG=function(){}
		SpeedG.prototype=new Goods();
		SpeedG.prototype.UseGoods=function(owner)
		{
			//调用父类方法
			Goods.prototype.UseGoods.call(this,owner);
			owner.Speed+=this.ValueStep;
		}

		LifG=function(){}
		LifG.prototype=new Goods();
		LifG.prototype.UseGoods=function(owner)
		{
			//调用父类方法
			Goods.prototype.UseGoods.call(this,owner);
			owner.LifeNum+=this.ValueStep;
		}

		DefendG=function(){}
		DefendG.prototype=new Goods();
		DefendG.prototype.UseGoods=function(owner)
		{
			//调用父类方法
			Goods.prototype.UseGoods.call(this,owner);
			owner.DefendVal+=this.ValueStep;
		}

		BombG=function(){}
		BombG.prototype=new Goods();
		BombG.prototype.UseGoods=function(owner)
		{
			//调用父类方法
			Goods.prototype.UseGoods.call(this,owner);
			owner.BombNum+=this.ValueStep;
		}
		/*--------------------↑↑↑↑↑物品对象群结束线↑↑↑↑↑-----------------------*/     
       
		//游戏载入对象（全局用）
		GameLoader = function() {
			this._this=this;
            this._level = 1;
			this._rowCount=13;
			this._colCount=13;
            this._needKillEnimyNum = 20;
            this._alreadyKillEnimyNum = 0;
            this._battleField = [];
            this._mapContainer = document.getElementById("divMap");
			this._selfTank=null;
			this._enimyTanks=[];
			this._explodeEffect=null;
        }
        GameLoader.prototype = {
			Begin:function() {
				//载入地图
				this.Load();
				
				//载入坦克
				var selfT=new SelfTank();
				selfT.XPosition=4;
				selfT.YPosition=12;
				selfT.UpdateUI(this._battleField);
				this._selfTank=selfT;
				
				var enimyT1=new EnimyTank();
				enimyT1.XPosition=0;
				enimyT1.YPosition=0;
				enimyT1.UpdateUI(this._battleField);
				this._enimyTanks.push(enimyT1);
				
				var enimyT2=new EnimyTank();
				enimyT2.XPosition=6;
				enimyT2.YPosition=0;
				enimyT2.UpdateUI(this._battleField);
				this._enimyTanks.push(enimyT2);

				var enimyT3=new EnimyTank();
				enimyT3.XPosition=12;
				enimyT3.YPosition=0;
				enimyT3.UpdateUI(this._battleField);
				this._enimyTanks.push(enimyT3);

/**/
				var warpper=UtilityClass.BindFunction(this,this.OnKeyDown);
				//按键检测，添加事件
				window.onkeydown=document.body.onkeydown=warpper;					
				
				warpper=UtilityClass.BindFunction(this,this.OnKeyUp);				
				/*按键弹起*/
				window.onkeyup=document.body.onkeyup=warpper;
				
				warpper=UtilityClass.BindFunction(this,this.Run);
				/*长定时器监听控制键*/
				var keyLister=setInterval(warpper,20);
			}
			,OnKeyDown:function(e)
			{
				switch ((window.event||e).keyCode){
					case 37:
						this._selfTank.Direction=EnumDirection.Left;
						this._selfTank.MovingState=true;
						break;		//左
					case 38:					
						this._selfTank.Direction=EnumDirection.Up;	
						this._selfTank.MovingState=true;
						break;		//上
					case 39:
						this._selfTank.Direction=EnumDirection.Right;
						this._selfTank.MovingState=true;
						break;		//右
					case 40:
						this._selfTank.Direction=EnumDirection.Down;
						this._selfTank.MovingState=true;
						break;		//下
					case 32:
						this._selfTank.Shot(this._battleField);

						break;		//空格
				}
				
			}
			,OnKeyUp:function(e)
			{
				switch ((window.event||e).keyCode){
						case 37:
						case 38:				
						case 39:
						case 40:
							this._selfTank.MovingState=false;
							break;		
					}
			}
			,EnimyAutoMove:function()
			{
				for(var i=0;i<this._enimyTanks.length;i++)
				{
					if(this._enimyTanks[i] instanceof Mover)
					{
						//Debug.Trace(this._enimyTanks[i]);
						this._enimyTanks[i].Move(this._battleField);

						if(Math.random()*100<10)
							this._enimyTanks[i].Shot(this._battleField);/* 0.5%的机率射击 */

					}
				}
			}
			/*游戏主循环运行函数，游戏的心脏，枢纽*/
			,Run:function()
			{
				//this.EnimyAutoMove();
				
				if(this._selfTank.MovingState)
				{
					this._selfTank.Move(this._battleField);
				}
			}
			,GetTdFromBattlField:function(x,y){
				//此处应该是y作为行，row ;  x作为列，col
				return this._battleField[y][x].UI;
			}
			,Load:function(){

				var map=Top_MapLevel[this._level-1].split(',');
				var mapBorder=UtilityClass.CreateE("div","","mapBorder",this._mapContainer);
				for(var i=0;i<this._rowCount;i++)
				{
					this._battleField[i]=[];
					var divRow=UtilityClass.CreateE("div","","",mapBorder);
					for(var j=0;j<this._colCount;j++)
					{
						var v=map[i]&&map[i].charAt(j)||0;/* 逐字符读取贴图数据 */
						var spanCol=UtilityClass.CreateE("span","","",divRow);	
						spanCol.className=ArrayCss[v];
						
						var to=null;
						switch(v)
						{
							case EnumMapCellType.Empty:
								to=new EmptyB();
								break;
							case EnumMapCellType.Wall:
								to=new WallB();
								break;								
							case EnumMapCellType.Steel:
								to=new SteelB();
								break;
							case EnumMapCellType.Tod:
								to=new TodB();
								break;
							case EnumMapCellType.River:
								to=new RiverB();
								break;
							case EnumMapCellType.Podium:
								to=new PodiumB();
								break;
							default:
								throw new Error("地图数字越界！");
								break;
						}
						to.UI=spanCol;
						//这里的j就是X，因为内部循环是横向的，x是横坐标
						to.XPosition=j;
						to.YPosition=i;

						this._battleField[i][j]={obj:to,occupier:null};
						//Debug.Trace("create:"+this._battleField[i][j].obj);
					}
				}
				window.BattleField=this._battleField;
			}
		}

//实现部分
        var GameLoad = new GameLoader();
        GameLoad.Begin();
    </script>

</body>
</html>
